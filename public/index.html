<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Pong | carnifexe-github-io.onrender.com</title>
  <style>
    :root {
      --primary: #4CAF50;
      --secondary: #2E7D32;
      --accent: #FFC107;
      --background: #121212;
      --surface: #1E1E1E;
      --error: #CF6679;
      --text-primary: #FFFFFF;
      --text-secondary: rgba(255, 255, 255, 0.7);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
    }

    h1 {
      color: var(--primary);
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }

    #connectionStatus {
      padding: 12px 20px;
      border-radius: 8px;
      margin: 10px 0;
      width: 100%;
      max-width: 800px;
      text-align: center;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .online {
      background-color: var(--secondary);
      border-left: 5px solid var(--primary);
    }

    .offline {
      background-color: #5c2a2a;
      border-left: 5px solid var(--error);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    #scoreBoard {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      margin: 10px 0;
      font-size: 1.5rem;
      font-weight: bold;
      background: var(--surface);
      padding: 10px 20px;
      border-radius: 8px;
    }

    #leftScore, #rightScore {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #gameCanvas {
      background: #000;
      border: 2px solid var(--surface);
      display: block;
      width: 800px;
      height: 600px;
      margin: 10px 0;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      touch-action: none;
    }

    #playersPanel {
      width: 100%;
      max-width: 800px;
      margin: 20px 0;
      background: var(--surface);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #playersPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    #playerList {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #playerList li {
      padding: 12px 15px;
      margin: 8px 0;
      border-radius: 6px;
      transition: all 0.3s ease;
    }

    #playerList li.playing {
      background-color: rgba(76, 175, 80, 0.1);
      border-left: 3px solid var(--primary);
    }

    #playerList li.empty {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    #playButton {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
      transition: all 0.2s ease;
    }

    #playButton:hover {
      background-color: var(--secondary);
      transform: translateY(-2px);
    }

    #gameInfo {
      margin-top: 15px;
      font-size: 0.9rem;
      color: var(--accent);
      text-align: center;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(255, 193, 7, 0.1);
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      #gameCanvas {
        width: 100%;
        height: 400px;
      }
      
      #scoreBoard {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Ultimate Pong</h1>
    <div id="connectionStatus">üü° Verbinde mit Server...</div>
  </header>

  <main id="gameContainer">
    <div id="scoreBoard">
      <div id="leftScore"><span id="leftPlayerName">Du</span>: <span>0</span></div>
      <div id="rightScore"><span id="rightPlayerName">Gegner</span>: <span>0</span></div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <section id="playersPanel">
      <h2>Spielstatus</h2>
      <ul id="playerList">
        <li class="empty">Verbinde mit Server...</li>
      </ul>
      <button id="playButton">Jetzt spielen</button>
      <div id="gameInfo">Bereit f√ºr ein Spiel?</div>
    </section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elemente
      const gameCanvas = document.getElementById('gameCanvas');
      const ctx = gameCanvas.getContext('2d');
      const playerList = document.getElementById('playerList');
      const connectionStatus = document.getElementById('connectionStatus');
      const playButton = document.getElementById('playButton');
      const gameInfo = document.getElementById('gameInfo');
      const leftScore = document.getElementById('leftScore').querySelector('span:last-child');
      const rightScore = document.getElementById('rightScore').querySelector('span:last-child');
      const leftPlayerName = document.getElementById('leftPlayerName');
      const rightPlayerName = document.getElementById('rightPlayerName');

      // Spielzustand
      const gameState = {
        leftPaddle: { y: 50, width: 15, height: 100, baseHeight: 100 },
        rightPaddle: { y: 50, width: 15, height: 100, baseHeight: 100 },
        ball: { 
          x: 50, 
          y: 50, 
          radius: 8, 
          speedX: 0, 
          speedY: 0,
          baseSpeed: 0.8,
          type: 'normal',
          color: '#FFFFFF'
        },
        scores: { left: 0, right: 0 },
        powerUps: [],
        currentGame: null,
        playerSide: null,
        opponentName: '',
        playerName: '',
        gameActive: false,
        isHost: false,
        lastPowerUpSpawn: 0,
        lastUpdate: Date.now()
      };

      // Canvas Gr√∂√üe anpassen
      function resizeCanvas() {
        const ratio = 800/600;
        if (window.innerWidth < 800) {
          gameCanvas.width = window.innerWidth - 40;
          gameCanvas.height = gameCanvas.width / ratio;
        } else {
          gameCanvas.width = 800;
          gameCanvas.height = 600;
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Socket.io Verbindung
      const socket = io('wss://carnifexe-github-io.onrender.com', {
        transports: ['websocket'],
        reconnectionAttempts: 5,
        reconnectionDelay: 3000
      });

      // Verbindungsstatus
      socket.on('connect', () => {
        console.log('Verbunden mit Server:', socket.id);
        connectionStatus.innerHTML = 'üü¢ ONLINE';
        connectionStatus.className = 'online';
        gameInfo.textContent = 'Bereit zum Spielen';
      });

      socket.on('disconnect', (reason) => {
        console.log('Verbindung getrennt:', reason);
        connectionStatus.innerHTML = 'üî¥ OFFLINE';
        connectionStatus.className = 'offline';
        gameState.gameActive = false;
        gameInfo.textContent = 'Verbindung verloren';
      });

      socket.on('connect_error', (err) => {
        console.error('Verbindungsfehler:', err);
        gameInfo.textContent = 'Verbindungsfehler - versuche erneut...';
      });

      // Warteschlangen-Update
      socket.on('queue_update', (data) => {
        console.log('Warteschlangen-Update:', data);
        gameInfo.textContent = `Warteposition: ${data.position} (ca. ${data.estimatedWait}s)`;
        playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
      });

      // Spielstart
      socket.on('game_start', (data) => {
        console.log('Spielstart:', data);
        gameState.currentGame = data.gameId;
        gameState.playerSide = data.playerSide;
        gameState.opponentName = data.opponent;
        gameState.gameActive = true;
        gameState.isHost = data.playerSide === 'left';
        
        // Initialzustand √ºbernehmen
        gameState.ball = {
          x: data.initialState.ball.x,
          y: data.initialState.ball.y,
          radius: 8,
          speedX: data.initialState.ball.speedX * 0.8,
          speedY: data.initialState.ball.speedY * 0.8,
          baseSpeed: 0.8,
          type: 'normal',
          color: '#FFFFFF'
        };
        gameState.scores = data.initialState.scores;
        gameState.leftPaddle.y = data.initialState.leftPaddleY;
        gameState.rightPaddle.y = data.initialState.rightPaddleY;
        
        // Spielernamen anzeigen
        if (gameState.playerSide === 'left') {
          leftPlayerName.textContent = gameState.playerName || 'Du';
          rightPlayerName.textContent = data.opponent;
        } else {
          leftPlayerName.textContent = data.opponent;
          rightPlayerName.textContent = gameState.playerName || 'Du';
        }
        
        // Scores aktualisieren
        leftScore.textContent = gameState.scores.left;
        rightScore.textContent = gameState.scores.right;
        
        playerList.innerHTML = `
          <li class="playing">
            Gegen ${data.opponent}
            <span class="status">(${gameState.playerSide === 'left' ? 'Links' : 'Rechts'})</span>
          </li>
        `;
        
        gameCanvas.style.cursor = 'none';
        gameInfo.textContent = 'Spiel l√§uft!';
        
        // Game Loop starten
        startGameLoop();
      });

      // Paddle-Bewegung
      socket.on('paddle_update', (data) => {
        if (!gameState.gameActive || gameState.currentGame !== data.gameId) return;
        
        // Nur das gegnerische Paddle aktualisieren
        if (gameState.playerSide === 'left') {
          gameState.rightPaddle.y = data.y;
        } else {
          gameState.leftPaddle.y = data.y;
        }
      });

      function handlePaddleMove(y) {
        if (!gameState.gameActive) return;
        
        // Eigenes Paddle bewegen
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        // Update an Server senden
        socket.emit('paddle_move', {
          gameId: gameState.currentGame,
          y: y,
          playerSide: gameState.playerSide
        });
      }

      function startGameLoop() {
        let lastTime = performance.now();
        
        function gameLoop(timestamp) {
          if (!gameState.gameActive) return;
          
          const deltaTime = timestamp - lastTime;
          lastTime = timestamp;
          
          // Ballbewegung nur vom Host berechnen
          if (gameState.isHost) {
            // Ball bewegen mit Zeit-basierter Bewegung
            gameState.ball.x += gameState.ball.speedX * (deltaTime / 16);
            gameState.ball.y += gameState.ball.speedY * (deltaTime / 16);
            
            // PowerUps spawnen
            if (timestamp - gameState.lastPowerUpSpawn > 10000 && Math.random() < 0.01) {
              spawnPowerUp();
              gameState.lastPowerUpSpawn = timestamp;
            }
            
            // PowerUps aktualisieren
            updatePowerUps();
            
            // Kollisionen pr√ºfen
            checkCollisions();
            
            // Update an Server senden
            socket.emit('game_update', {
              gameId: gameState.currentGame,
              ball: gameState.ball,
              scores: gameState.scores,
              leftPaddle: gameState.leftPaddle,
              rightPaddle: gameState.rightPaddle,
              powerUps: gameState.powerUps,
              isHost: true
            });
          }
          
          render();
          requestAnimationFrame(gameLoop);
        }
        gameLoop(lastTime);
      }

      function spawnPowerUp() {
        const types = ['bigPaddle', 'smallPaddle', 'fastBall', 'slowBall'];
        const type = types[Math.floor(Math.random() * types.length)];
        
        gameState.powerUps.push({
          x: 10 + Math.random() * 80,
          y: 10 + Math.random() * 80,
          radius: 5,
          type: type,
          color: getPowerUpColor(type)
        });
      }

      function getPowerUpColor(type) {
        switch(type) {
          case 'bigPaddle': return '#4CAF50';
          case 'smallPaddle': return '#F44336';
          case 'fastBall': return '#FFC107';
          case 'slowBall': return '#2196F3';
          default: return '#FFFFFF';
        }
      }

      function updatePowerUps() {
        // PowerUps mit Ball kollidieren
        gameState.powerUps = gameState.powerUps.filter(powerUp => {
          const distance = Math.sqrt(
            Math.pow(gameState.ball.x - powerUp.x, 2) + 
            Math.pow(gameState.ball.y - powerUp.y, 2)
          );
          
          if (distance < gameState.ball.radius + powerUp.radius) {
            activatePowerUp(powerUp.type);
            return false;
          }
          return true;
        });
      }

      function activatePowerUp(type) {
        // PowerUp Effekte
        switch(type) {
          case 'bigPaddle':
            if (gameState.playerSide === 'left') {
              gameState.leftPaddle.height = gameState.leftPaddle.baseHeight * 1.5;
            } else {
              gameState.rightPaddle.height = gameState.rightPaddle.baseHeight * 1.5;
            }
            setTimeout(resetPaddles, 5000);
            break;
            
          case 'smallPaddle':
            if (gameState.playerSide === 'left') {
              gameState.rightPaddle.height = gameState.rightPaddle.baseHeight * 0.7;
            } else {
              gameState.leftPaddle.height = gameState.leftPaddle.baseHeight * 0.7;
            }
            setTimeout(resetPaddles, 5000);
            break;
            
          case 'fastBall':
            gameState.ball.speedX *= 1.5;
            gameState.ball.speedY *= 1.5;
            setTimeout(() => {
              gameState.ball.speedX = Math.sign(gameState.ball.speedX) * gameState.ball.baseSpeed;
              gameState.ball.speedY = Math.sign(gameState.ball.speedY) * gameState.ball.baseSpeed;
            }, 5000);
            break;
            
          case 'slowBall':
            gameState.ball.speedX *= 0.5;
            gameState.ball.speedY *= 0.5;
            setTimeout(() => {
              gameState.ball.speedX = Math.sign(gameState.ball.speedX) * gameState.ball.baseSpeed;
              gameState.ball.speedY = Math.sign(gameState.ball.speedY) * gameState.ball.baseSpeed;
            }, 5000);
            break;
        }
      }

      function resetPaddles() {
        gameState.leftPaddle.height = gameState.leftPaddle.baseHeight;
        gameState.rightPaddle.height = gameState.rightPaddle.baseHeight;
      }

      function checkCollisions() {
        // Pr√§zisere Kollisionserkennung
        const ballLeft = gameState.ball.x - gameState.ball.radius;
        const ballRight = gameState.ball.x + gameState.ball.radius;
        const ballTop = gameState.ball.y - gameState.ball.radius;
        const ballBottom = gameState.ball.y + gameState.ball.radius;
        
        // Wandkollision
        if (ballTop <= 0 || ballBottom >= 100) {
          gameState.ball.speedY *= -1;
          gameState.ball.y = Math.max(gameState.ball.radius, Math.min(100 - gameState.ball.radius, gameState.ball.y));
        }
        
        // Linker Schl√§ger
        const paddleLeft = 20;
        const paddleRight = 20 + gameState.leftPaddle.width;
        const paddleTop = gameState.leftPaddle.y - gameState.leftPaddle.height/2;
        const paddleBottom = gameState.leftPaddle.y + gameState.leftPaddle.height/2;
        
        if (ballLeft <= paddleRight && 
            ballRight >= paddleLeft && 
            ballTop <= paddleBottom && 
            ballBottom >= paddleTop) {
          gameState.ball.x = paddleRight + gameState.ball.radius;
          gameState.ball.speedX = Math.abs(gameState.ball.speedX) * 1.05;
          
          // Winkel basierend auf Trefferposition
          const relativeIntersectY = (gameState.leftPaddle.y - gameState.ball.y) / (gameState.leftPaddle.height/2);
          gameState.ball.speedY = relativeIntersectY * gameState.ball.baseSpeed * -1;
        }
        
        // Rechter Schl√§ger
        const paddleRight2 = 100 - 20;
        const paddleLeft2 = 100 - 20 - gameState.rightPaddle.width;
        const paddleTop2 = gameState.rightPaddle.y - gameState.rightPaddle.height/2;
        const paddleBottom2 = gameState.rightPaddle.y + gameState.rightPaddle.height/2;
        
        if (ballRight >= paddleLeft2 && 
            ballLeft <= paddleRight2 && 
            ballTop <= paddleBottom2 && 
            ballBottom >= paddleTop2) {
          gameState.ball.x = paddleLeft2 - gameState.ball.radius;
          gameState.ball.speedX = -Math.abs(gameState.ball.speedX) * 1.05;
          
          // Winkel basierend auf Trefferposition
          const relativeIntersectY = (gameState.rightPaddle.y - gameState.ball.y) / (gameState.rightPaddle.height/2);
          gameState.ball.speedY = relativeIntersectY * gameState.ball.baseSpeed * -1;
        }
        
        // Punkte
        if (gameState.ball.x < 0 || gameState.ball.x > 100) {
          if (gameState.ball.x < 0) {
            gameState.scores.right++;
            gameState.rightPaddle.baseHeight = Math.min(150, gameState.rightPaddle.baseHeight + 10);
            gameState.rightPaddle.height = gameState.rightPaddle.baseHeight;
          } else {
            gameState.scores.left++;
            gameState.leftPaddle.baseHeight = Math.min(150, gameState.leftPaddle.baseHeight + 10);
            gameState.leftPaddle.height = gameState.leftPaddle.baseHeight;
          }
          resetBall();
        }
      }

      function resetBall() {
        gameState.ball = { 
          x: 50, 
          y: 50,
          radius: 8,
          speedX: (Math.random() > 0.5 ? 1 : -1) * gameState.ball.baseSpeed,
          speedY: (Math.random() * 2 - 1) * gameState.ball.baseSpeed,
          baseSpeed: gameState.ball.baseSpeed,
          type: 'normal',
          color: '#FFFFFF'
        };
        
        // PowerUps zur√ºcksetzen
        gameState.powerUps = [];
      }

      // Spielupdate
      socket.on('game_update', (data) => {
        if (!gameState.gameActive || !data) return;
        
        if (data.ball) {
          gameState.ball = data.ball;
        }
        
        if (data.scores) {
          gameState.scores = data.scores;
          leftScore.textContent = gameState.scores.left;
          rightScore.textContent = gameState.scores.right;
        }
        
        if (data.powerUps) {
          gameState.powerUps = data.powerUps;
        }
      });

      // Spielende
      socket.on('game_ended', (data) => {
        console.log('Spiel beendet:', data);
        gameState.gameActive = false;
        gameCanvas.style.cursor = 'default';
        
        if (data.reason === 'opponent_disconnected') {
          playerList.innerHTML = '<li class="empty">Gegner hat das Spiel verlassen</li>';
          gameInfo.textContent = 'Spiel beendet';
        }
      });

      // Spielen-Button
      playButton.addEventListener('click', () => {
        if (socket.connected) {
          gameState.playerName = prompt('Dein Spielername:', `Spieler_${Math.floor(Math.random()*1000)}`);
          const nameToSend = gameState.playerName || `Spieler_${socket.id.substr(0, 4)}`;
          
          socket.emit('join_queue', nameToSend);
          playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
          gameInfo.textContent = 'Verbinde...';
        } else {
          alert('Keine Serververbindung!');
        }
      });

      // Event-Listener f√ºr Paddle-Bewegung
      gameCanvas.addEventListener('mousemove', (e) => {
        const rect = gameCanvas.getBoundingClientRect();
        const y = Math.max(0, Math.min(100, ((e.clientY - rect.top) / gameCanvas.height) * 100));
        handlePaddleMove(y);
      });

      gameCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = gameCanvas.getBoundingClientRect();
        const y = Math.max(0, Math.min(100, ((touch.clientY - rect.top) / gameCanvas.height) * 100));
        handlePaddleMove(y);
      }, { passive: false });

      // Render-Funktion
      function render() {
        if (!gameState.gameActive) return;
        
        // Hintergrund
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        // Mittellinie
        ctx.setLineDash([15, 15]);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(gameCanvas.width/2, 0);
        ctx.lineTo(gameCanvas.width/2, gameCanvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Schl√§ger
        ctx.fillStyle = '#FFF';
        // Linker Schl√§ger
        ctx.fillRect(
          20, 
          (gameState.leftPaddle.y/100)*gameCanvas.height - gameState.leftPaddle.height/2, 
          gameState.leftPaddle.width, 
          gameState.leftPaddle.height
        );
        // Rechter Schl√§ger
        ctx.fillRect(
          gameCanvas.width - 20 - gameState.rightPaddle.width, 
          (gameState.rightPaddle.y/100)*gameCanvas.height - gameState.rightPaddle.height/2, 
          gameState.rightPaddle.width, 
          gameState.rightPaddle.height
        );
        
        // PowerUps zeichnen
        gameState.powerUps.forEach(powerUp => {
          ctx.fillStyle = powerUp.color;
          ctx.beginPath();
          ctx.arc(
            (powerUp.x/100)*gameCanvas.width,
            (powerUp.y/100)*gameCanvas.height,
            powerUp.radius * 2,
            0,
            Math.PI*2
          );
          ctx.fill();
        });
        
        // Ball zeichnen
        ctx.fillStyle = gameState.ball.color;
        ctx.beginPath();
        ctx.arc(
          (gameState.ball.x/100)*gameCanvas.width,
          (gameState.ball.y/100)*gameCanvas.height,
          gameState.ball.radius,
          0,
          Math.PI*2
        );
        ctx.fill();
        
        // Spielernamen anzeigen
        ctx.fillStyle = '#FFF';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(leftPlayerName.textContent, gameCanvas.width * 0.25, 30);
        ctx.fillText(rightPlayerName.textContent, gameCanvas.width * 0.75, 30);
        
        // Punktestand anzeigen
        ctx.font = '24px Arial';
        ctx.fillText(gameState.scores.left, gameCanvas.width * 0.25, 60);
        ctx.fillText(gameState.scores.right, gameCanvas.width * 0.75, 60);
      }
    });
  </script>
</body>
</html>
