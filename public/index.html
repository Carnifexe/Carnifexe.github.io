<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Pong | carnifexe-github-io.onrender.com</title>
  <style>
    :root {
      --primary: #4CAF50;
      --secondary: #2E7D32;
      --accent: #FFC107;
      --background: #121212;
      --surface: #1E1E1E;
      --error: #CF6679;
      --text-primary: #FFFFFF;
      --text-secondary: rgba(255, 255, 255, 0.7);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
    }

    h1 {
      color: var(--primary);
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }

    #connectionStatus {
      padding: 12px 20px;
      border-radius: 8px;
      margin: 10px 0;
      width: 100%;
      max-width: 800px;
      text-align: center;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .online {
      background-color: var(--secondary);
      border-left: 5px solid var(--primary);
    }

    .offline {
      background-color: #5c2a2a;
      border-left: 5px solid var(--error);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    #scoreBoard {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      margin: 10px 0;
      font-size: 1.5rem;
      font-weight: bold;
      background: var(--surface);
      padding: 10px 20px;
      border-radius: 8px;
    }

    #leftScore, #rightScore {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #gameCanvas {
      background: #000;
      border: 2px solid var(--surface);
      display: block;
      width: 800px;
      height: 600px;
      margin: 10px 0;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      touch-action: none;
    }

    #playersPanel {
      width: 100%;
      max-width: 800px;
      margin: 20px 0;
      background: var(--surface);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #playersPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    #playerList {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #playerList li {
      padding: 12px 15px;
      margin: 8px 0;
      border-radius: 6px;
      transition: all 0.3s ease;
    }

    #playerList li.playing {
      background-color: rgba(76, 175, 80, 0.1);
      border-left: 3px solid var(--primary);
    }

    #playerList li.empty {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    #playButton {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
      transition: all 0.2s ease;
    }

    #playButton:hover {
      background-color: var(--secondary);
      transform: translateY(-2px);
    }

    #gameInfo {
      margin-top: 15px;
      font-size: 0.9rem;
      color: var(--accent);
      text-align: center;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(255, 193, 7, 0.1);
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      #gameCanvas {
        width: 100%;
        height: 400px;
      }
      
      #scoreBoard {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Ultimate Pong</h1>
    <div id="connectionStatus">üü° Verbinde mit Server...</div>
  </header>

  <main id="gameContainer">
    <div id="scoreBoard">
      <div id="leftScore"><span id="leftPlayerName">Du</span>: <span>0</span></div>
      <div id="rightScore"><span id="rightPlayerName">Gegner</span>: <span>0</span></div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <section id="playersPanel">
      <h2>Spielstatus</h2>
      <ul id="playerList">
        <li class="empty">Verbinde mit Server...</li>
      </ul>
      <button id="playButton">Jetzt spielen</button>
      <div id="gameInfo">Bereit f√ºr ein Spiel?</div>
    </section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elemente
      const gameCanvas = document.getElementById('gameCanvas');
      const ctx = gameCanvas.getContext('2d');
      const playerList = document.getElementById('playerList');
      const connectionStatus = document.getElementById('connectionStatus');
      const playButton = document.getElementById('playButton');
      const gameInfo = document.getElementById('gameInfo');
      const leftScore = document.getElementById('leftScore').querySelector('span:last-child');
      const rightScore = document.getElementById('rightScore').querySelector('span:last-child');
      const leftPlayerName = document.getElementById('leftPlayerName');
      const rightPlayerName = document.getElementById('rightPlayerName');

      // Spielkonstanten
      const PADDLE_WIDTH = 2;
      const PADDLE_HEIGHT = 15;
      const BALL_RADIUS = 1.5;
      const BALL_SPEED = 0.5;
      const FIELD_WIDTH = 100;
      const FIELD_HEIGHT = 100;

      // Spielzustand
      const gameState = {
        leftPaddle: { y: 50, width: PADDLE_WIDTH, height: PADDLE_HEIGHT },
        rightPaddle: { y: 50, width: PADDLE_WIDTH, height: PADDLE_HEIGHT },
        ball: { 
          x: 50, 
          y: 50, 
          radius: BALL_RADIUS, 
          speedX: BALL_SPEED, 
          speedY: 0,
          lastUpdate: Date.now()
        },
        scores: { left: 0, right: 0 },
        gameId: null,
        playerSide: null,
        opponentName: '',
        playerName: '',
        gameActive: false,
        isHost: false,
        lastRender: 0
      };

      // Canvas Gr√∂√üe anpassen
      function resizeCanvas() {
        const ratio = 800/600;
        if (window.innerWidth < 800) {
          gameCanvas.width = window.innerWidth - 40;
          gameCanvas.height = gameCanvas.width / ratio;
        } else {
          gameCanvas.width = 800;
          gameCanvas.height = 600;
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Socket.io Verbindung
      const socket = io('wss://carnifexe-github-io.onrender.com', {
        transports: ['websocket'],
        reconnectionAttempts: 5,
        reconnectionDelay: 3000
      });

      // Verbindungsstatus
      socket.on('connect', () => {
        console.log('Verbunden mit Server:', socket.id);
        connectionStatus.innerHTML = 'üü¢ ONLINE';
        connectionStatus.className = 'online';
        gameInfo.textContent = 'Bereit zum Spielen';
      });

      socket.on('disconnect', (reason) => {
        console.log('Verbindung getrennt:', reason);
        connectionStatus.innerHTML = 'üî¥ OFFLINE';
        connectionStatus.className = 'offline';
        gameState.gameActive = false;
        gameInfo.textContent = 'Verbindung verloren';
      });

      socket.on('connect_error', (err) => {
        console.error('Verbindungsfehler:', err);
        gameInfo.textContent = 'Verbindungsfehler - versuche erneut...';
      });

      // Warteschlangen-Update
      socket.on('queue_update', (data) => {
        console.log('Warteschlangen-Update:', data);
        gameInfo.textContent = `Warteposition: ${data.position} (ca. ${data.estimatedWait}s)`;
        playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
      });

      // Spielstart
      socket.on('game_start', (data) => {
        console.log('Spielstart:', data);
        gameState.gameId = data.gameId;
        gameState.playerSide = data.playerSide;
        gameState.opponentName = data.opponent;
        gameState.gameActive = true;
        gameState.isHost = data.playerSide === 'left';
        
        // Initialzustand setzen
        resetBall();
        gameState.scores = { left: 0, right: 0 };
        
        // Spielernamen anzeigen
        if (gameState.playerSide === 'left') {
          leftPlayerName.textContent = gameState.playerName || 'Du';
          rightPlayerName.textContent = data.opponent;
          gameState.ball.speedX = BALL_SPEED;
        } else {
          leftPlayerName.textContent = data.opponent;
          rightPlayerName.textContent = gameState.playerName || 'Du';
          gameState.ball.speedX = -BALL_SPEED;
        }
        
        // Scores zur√ºcksetzen
        leftScore.textContent = '0';
        rightScore.textContent = '0';
        
        playerList.innerHTML = `
          <li class="playing">
            Gegen ${data.opponent}
            <span class="status">(${gameState.playerSide === 'left' ? 'Links' : 'Rechts'})</span>
          </li>
        `;
        
        gameCanvas.style.cursor = 'none';
        gameInfo.textContent = 'Spiel l√§uft!';
        
        // Game Loop starten
        startGameLoop();
      });

      // Paddle Updates vom Gegner
      socket.on('paddle_update', (data) => {
        if (gameState.gameActive && gameState.gameId === data.gameId) {
          if (data.side !== gameState.playerSide) {
            if (data.side === 'left') {
              gameState.leftPaddle.y = data.y;
            } else {
              gameState.rightPaddle.y = data.y;
            }
          }
        }
      });

      // Ball Updates vom Host
      socket.on('ball_update', (data) => {
        if (gameState.gameActive && gameState.gameId === data.gameId) {
          if (!gameState.isHost) {
            gameState.ball.x = data.x;
            gameState.ball.y = data.y;
            gameState.ball.speedX = data.speedX;
            gameState.ball.speedY = data.speedY;
            gameState.ball.lastUpdate = Date.now();
          }
        }
      });

      // Score Updates
      socket.on('score_update', (data) => {
        if (gameState.gameActive && gameState.gameId === data.gameId) {
          gameState.scores = data.scores;
          leftScore.textContent = gameState.scores.left;
          rightScore.textContent = gameState.scores.right;
        }
      });

      // Spielende
      socket.on('game_ended', (data) => {
        console.log('Spiel beendet:', data);
        gameState.gameActive = false;
        gameCanvas.style.cursor = 'default';
        
        if (data.reason === 'opponent_disconnected') {
          playerList.innerHTML = '<li class="empty">Gegner hat das Spiel verlassen</li>';
          gameInfo.textContent = 'Spiel beendet';
        }
      });

      // Spielschleife
      function startGameLoop() {
        function gameLoop(timestamp) {
          if (!gameState.gameActive) return;
          
          const deltaTime = timestamp - gameState.lastRender;
          gameState.lastRender = timestamp;
          
          // Ballphysik nur vom Host berechnen
          if (gameState.isHost) {
            updateBallPhysics(deltaTime);
          }
          
          render();
          requestAnimationFrame(gameLoop);
        }
        gameLoop(0);
      }

      // Pr√§zise Ballphysik
      function updateBallPhysics(deltaTime) {
        const timeFactor = deltaTime / 16;
        
        // Ball bewegen
        gameState.ball.x += gameState.ball.speedX * timeFactor;
        gameState.ball.y += gameState.ball.speedY * timeFactor;
        
        // Wandkollision oben/unten
        if (gameState.ball.y - BALL_RADIUS <= 0 || gameState.ball.y + BALL_RADIUS >= FIELD_HEIGHT) {
          gameState.ball.speedY *= -1;
          gameState.ball.y = Math.max(BALL_RADIUS, Math.min(FIELD_HEIGHT - BALL_RADIUS, gameState.ball.y));
        }
        
        // Paddle Kollision links
        if (gameState.ball.x - BALL_RADIUS <= 5 + PADDLE_WIDTH && 
            gameState.ball.y >= gameState.leftPaddle.y - PADDLE_HEIGHT/2 &&
            gameState.ball.y <= gameState.leftPaddle.y + PADDLE_HEIGHT/2) {
          
          // Trefferposition berechnen (-0.5 bis 0.5)
          const hitPos = (gameState.ball.y - gameState.leftPaddle.y) / PADDLE_HEIGHT;
          
          gameState.ball.speedX = Math.abs(gameState.ball.speedX) * 1.05;
          gameState.ball.speedY = hitPos * 2; // Winkel basierend auf Trefferposition
          
          // Ball nach rechts setzen
          gameState.ball.x = 5 + PADDLE_WIDTH + BALL_RADIUS;
        }
        
        // Paddle Kollision rechts
        if (gameState.ball.x + BALL_RADIUS >= 95 - PADDLE_WIDTH && 
            gameState.ball.y >= gameState.rightPaddle.y - PADDLE_HEIGHT/2 &&
            gameState.ball.y <= gameState.rightPaddle.y + PADDLE_HEIGHT/2) {
          
          const hitPos = (gameState.ball.y - gameState.rightPaddle.y) / PADDLE_HEIGHT;
          
          gameState.ball.speedX = -Math.abs(gameState.ball.speedX) * 1.05;
          gameState.ball.speedY = hitPos * 2;
          
          gameState.ball.x = 95 - PADDLE_WIDTH - BALL_RADIUS;
        }
        
        // Punkte
        if (gameState.ball.x < 0 || gameState.ball.x > FIELD_WIDTH) {
          if (gameState.ball.x < 0) {
            gameState.scores.right++;
          } else {
            gameState.scores.left++;
          }
          
          // Ball zur√ºcksetzen
          resetBall();
          
          // Scores aktualisieren
          socket.emit('score_update', {
            gameId: gameState.gameId,
            scores: gameState.scores
          });
        }
        
        // Ball Update senden
        socket.emit('ball_update', {
          gameId: gameState.gameId,
          x: gameState.ball.x,
          y: gameState.ball.y,
          speedX: gameState.ball.speedX,
          speedY: gameState.ball.speedY
        });
      }

      function resetBall() {
        gameState.ball.x = 50;
        gameState.ball.y = 50;
        gameState.ball.speedX = (Math.random() > 0.5 ? 1 : -1) * BALL_SPEED;
        gameState.ball.speedY = (Math.random() * 2 - 1) * BALL_SPEED;
        gameState.ball.lastUpdate = Date.now();
      }

      // Input Handling
      gameCanvas.addEventListener('mousemove', (e) => {
        if (!gameState.gameActive) return;
        
        const rect = gameCanvas.getBoundingClientRect();
        const y = Math.max(PADDLE_HEIGHT/2, Math.min(FIELD_HEIGHT - PADDLE_HEIGHT/2, 
          (e.clientY - rect.top) / gameCanvas.height * FIELD_HEIGHT));
        
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        // Paddle Update senden
        socket.emit('paddle_update', {
          gameId: gameState.gameId,
          side: gameState.playerSide,
          y: y
        });
      });

      // Touch-Steuerung
      gameCanvas.addEventListener('touchmove', (e) => {
        if (!gameState.gameActive) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const rect = gameCanvas.getBoundingClientRect();
        const y = Math.max(PADDLE_HEIGHT/2, Math.min(FIELD_HEIGHT - PADDLE_HEIGHT/2, 
          (touch.clientY - rect.top) / gameCanvas.height * FIELD_HEIGHT));
        
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        socket.emit('paddle_update', {
          gameId: gameState.gameId,
          side: gameState.playerSide,
          y: y
        });
      }, { passive: false });

      // Render-Funktion
      function render() {
        // Hintergrund
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        // Mittellinie
        ctx.strokeStyle = '#333';
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(gameCanvas.width/2, 0);
        ctx.lineTo(gameCanvas.width/2, gameCanvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Schl√§ger
        ctx.fillStyle = '#FFF';
        // Linker Schl√§ger
        ctx.fillRect(
          0.05 * gameCanvas.width,
          (gameState.leftPaddle.y/FIELD_HEIGHT) * gameCanvas.height - (PADDLE_HEIGHT/FIELD_HEIGHT)/2 * gameCanvas.height,
          (PADDLE_WIDTH/FIELD_WIDTH) * gameCanvas.width,
          (PADDLE_HEIGHT/FIELD_HEIGHT) * gameCanvas.height
        );
        // Rechter Schl√§ger
        ctx.fillRect(
          0.95 * gameCanvas.width - (PADDLE_WIDTH/FIELD_WIDTH) * gameCanvas.width,
          (gameState.rightPaddle.y/FIELD_HEIGHT) * gameCanvas.height - (PADDLE_HEIGHT/FIELD_HEIGHT)/2 * gameCanvas.height,
          (PADDLE_WIDTH/FIELD_WIDTH) * gameCanvas.width,
          (PADDLE_HEIGHT/FIELD_HEIGHT) * gameCanvas.height
        );
        
        // Ball
        ctx.beginPath();
        ctx.arc(
          (gameState.ball.x/FIELD_WIDTH) * gameCanvas.width,
          (gameState.ball.y/FIELD_HEIGHT) * gameCanvas.height,
          (BALL_RADIUS/FIELD_WIDTH) * gameCanvas.width,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        // Scores
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(gameState.scores.left, gameCanvas.width * 0.25, 50);
        ctx.fillText(gameState.scores.right, gameCanvas.width * 0.75, 50);
      }

      // Spieler verbinden
      playButton.addEventListener('click', () => {
        if (socket.connected) {
          gameState.playerName = prompt('Dein Spielername:', `Spieler_${Math.floor(Math.random()*1000)}`);
          const nameToSend = gameState.playerName || `Spieler_${socket.id.substr(0, 4)}`;
          socket.emit('join_queue', nameToSend);
          playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
          gameInfo.textContent = 'Verbinde...';
        } else {
          alert('Keine Serververbindung!');
        }
      });
    });
  </script>
</body>
</html>
