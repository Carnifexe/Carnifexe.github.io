<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Pong | carnifexe-github-io.onrender.com</title>
  <style>
    :root {
      --primary: #4CAF50;
      --secondary: #2E7D32;
      --accent: #FFC107;
      --background: #121212;
      --surface: #1E1E1E;
      --error: #CF6679;
      --text-primary: #FFFFFF;
      --text-secondary: rgba(255, 255, 255, 0.7);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
    }

    h1 {
      color: var(--primary);
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }

    #connectionStatus {
      padding: 12px 20px;
      border-radius: 8px;
      margin: 10px 0;
      width: 100%;
      max-width: 800px;
      text-align: center;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .online {
      background-color: var(--secondary);
      border-left: 5px solid var(--primary);
    }

    .offline {
      background-color: #5c2a2a;
      border-left: 5px solid var(--error);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    #scoreBoard {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      margin: 10px 0;
      font-size: 1.5rem;
      font-weight: bold;
      background: var(--surface);
      padding: 10px 20px;
      border-radius: 8px;
    }

    #leftScore, #rightScore {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #gameCanvas {
      background: #000;
      border: 2px solid var(--surface);
      display: block;
      width: 800px;
      height: 600px;
      margin: 10px 0;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      touch-action: none;
    }

    #playersPanel {
      width: 100%;
      max-width: 800px;
      margin: 20px 0;
      background: var(--surface);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #playersPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    #playerList {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #playerList li {
      padding: 12px 15px;
      margin: 8px 0;
      border-radius: 6px;
      transition: all 0.3s ease;
    }

    #playerList li.playing {
      background-color: rgba(76, 175, 80, 0.1);
      border-left: 3px solid var(--primary);
    }

    #playerList li.empty {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    #playButton {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
      transition: all 0.2s ease;
    }

    #playButton:hover {
      background-color: var(--secondary);
      transform: translateY(-2px);
    }

    #gameInfo {
      margin-top: 15px;
      font-size: 0.9rem;
      color: var(--accent);
      text-align: center;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(255, 193, 7, 0.1);
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      #gameCanvas {
        width: 100%;
        height: 400px;
      }
      
      #scoreBoard {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Ultimate Pong</h1>
    <div id="connectionStatus">üü° Verbinde mit Server...</div>
  </header>

  <main id="gameContainer">
    <div id="scoreBoard">
      <div id="leftScore"><span id="leftPlayerName">Du</span>: <span>0</span></div>
      <div id="rightScore"><span id="rightPlayerName">Gegner</span>: <span>0</span></div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <section id="playersPanel">
      <h2>Spielstatus</h2>
      <ul id="playerList">
        <li class="empty">Verbinde mit Server...</li>
      </ul>
      <button id="playButton">Jetzt spielen</button>
      <div id="gameInfo">Bereit f√ºr ein Spiel?</div>
    </section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elemente
      const gameCanvas = document.getElementById('gameCanvas');
      const ctx = gameCanvas.getContext('2d');
      const playerList = document.getElementById('playerList');
      const connectionStatus = document.getElementById('connectionStatus');
      const playButton = document.getElementById('playButton');
      const gameInfo = document.getElementById('gameInfo');
      const leftScore = document.getElementById('leftScore').querySelector('span:last-child');
      const rightScore = document.getElementById('rightScore').querySelector('span:last-child');
      const leftPlayerName = document.getElementById('leftPlayerName');
      const rightPlayerName = document.getElementById('rightPlayerName');

      // Spielzustand
      const gameState = {
        leftPaddle: { y: 50, width: 15, height: 100 },
        rightPaddle: { y: 50, width: 15, height: 100 },
        ball: { x: 50, y: 50, radius: 8, speedX: 0, speedY: 0 },
        scores: { left: 0, right: 0 },
        currentGame: null,
        playerSide: null,
        opponentName: '',
        playerName: '',
        gameActive: false,
        isHost: false
      };

      // Canvas Gr√∂√üe anpassen
      function resizeCanvas() {
        const ratio = 800/600;
        if (window.innerWidth < 800) {
          gameCanvas.width = window.innerWidth - 40;
          gameCanvas.height = gameCanvas.width / ratio;
        } else {
          gameCanvas.width = 800;
          gameCanvas.height = 600;
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Socket.io Verbindung
      const socket = io('wss://carnifexe-github-io.onrender.com', {
        transports: ['websocket'],
        reconnectionAttempts: 5,
        reconnectionDelay: 3000
      });

      // Verbindungsstatus
      socket.on('connect', () => {
        console.log('Verbunden mit Server:', socket.id);
        connectionStatus.innerHTML = 'üü¢ ONLINE';
        connectionStatus.className = 'online';
        gameInfo.textContent = 'Bereit zum Spielen';
      });

      socket.on('disconnect', (reason) => {
        console.log('Verbindung getrennt:', reason);
        connectionStatus.innerHTML = 'üî¥ OFFLINE';
        connectionStatus.className = 'offline';
        gameState.gameActive = false;
        gameInfo.textContent = 'Verbindung verloren';
      });

      socket.on('connect_error', (err) => {
        console.error('Verbindungsfehler:', err);
        gameInfo.textContent = 'Verbindungsfehler - versuche erneut...';
      });

      // Warteschlangen-Update
      socket.on('queue_update', (data) => {
        console.log('Warteschlangen-Update:', data);
        gameInfo.textContent = `Warteposition: ${data.position} (ca. ${data.estimatedWait}s)`;
        playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
      });

      // Spielstart
      socket.on('game_start', (data) => {
        console.log('Spielstart:', data);
        gameState.currentGame = data.gameId;
        gameState.playerSide = data.playerSide;
        gameState.opponentName = data.opponent;
        gameState.gameActive = true;
        gameState.isHost = data.playerSide === 'left';
        
        // Initialzustand √ºbernehmen
        gameState.ball = {
          x: data.initialState.ball.x,
          y: data.initialState.ball.y,
          speedX: data.initialState.ball.speedX,
          speedY: data.initialState.ball.speedY,
          radius: 8
        };
        gameState.scores = data.initialState.scores;
        gameState.leftPaddle.y = data.initialState.leftPaddleY;
        gameState.rightPaddle.y = data.initialState.rightPaddleY;
        
        // Spielernamen anzeigen
        if (gameState.playerSide === 'left') {
          leftPlayerName.textContent = gameState.playerName || 'Du';
          rightPlayerName.textContent = data.opponent;
        } else {
          leftPlayerName.textContent = data.opponent;
          rightPlayerName.textContent = gameState.playerName || 'Du';
        }
        
        // Scores aktualisieren
        leftScore.textContent = gameState.scores.left;
        rightScore.textContent = gameState.scores.right;
        
        playerList.innerHTML = `
          <li class="playing">
            Gegen ${data.opponent}
            <span class="status">(${gameState.playerSide === 'left' ? 'Links' : 'Rechts'})</span>
          </li>
        `;
        
        gameCanvas.style.cursor = 'none';
        gameInfo.textContent = 'Spiel l√§uft!';
        
        // Game Loop starten
        startGameLoop();
      });

      function startGameLoop() {
        function gameLoop() {
          if (!gameState.gameActive) return;
          
          // Ballbewegung nur vom Host berechnen
          if (gameState.isHost) {
            gameState.ball.x += gameState.ball.speedX;
            gameState.ball.y += gameState.ball.speedY;
            
            // Kollisionen pr√ºfen
            checkCollisions();
            
            // Update an Server senden
            socket.emit('game_update', {
              gameId: gameState.currentGame,
              ball: gameState.ball,
              scores: gameState.scores,
              isHost: true
            });
          }
          
          render();
          requestAnimationFrame(gameLoop);
        }
        gameLoop();
      }

      function checkCollisions() {
        // Wandkollision
        if (gameState.ball.y - gameState.ball.radius <= 0 || 
            gameState.ball.y + gameState.ball.radius >= 100) {
          gameState.ball.speedY *= -1;
        }
        
        // Schl√§gerkollision (nur Host pr√ºft)
        if (gameState.isHost) {
          if (gameState.ball.x - gameState.ball.radius <= 20 + 15 && 
              Math.abs(gameState.ball.y - gameState.leftPaddle.y) < 15) {
            gameState.ball.speedX = Math.abs(gameState.ball.speedX) * 1.05;
          }
          if (gameState.ball.x + gameState.ball.radius >= gameCanvas.width - 20 - 15 && 
              Math.abs(gameState.ball.y - gameState.rightPaddle.y) < 15) {
            gameState.ball.speedX = -Math.abs(gameState.ball.speedX) * 1.05;
          }
          
          // Punkte
          if (gameState.ball.x < 0 || gameState.ball.x > 100) {
            if (gameState.ball.x < 0) gameState.scores.right++;
            else gameState.scores.left++;
            resetBall();
          }
        }
      }

      function resetBall() {
        gameState.ball = { 
          x: 50, 
          y: 50,
          speedX: (Math.random() > 0.5 ? 1 : -1) * 2,
          speedY: (Math.random() * 2 - 1) * 2,
          radius: 8
        };
      }

      // Spielupdate
      socket.on('game_update', (data) => {
        if (!gameState.gameActive) return;
        
        if (data.ball) {
          gameState.ball = data.ball;
        }
        
        if (data.scores) {
          gameState.scores = data.scores;
          leftScore.textContent = gameState.scores.left;
          rightScore.textContent = gameState.scores.right;
        }
        
        if (data.paddleY !== undefined) {
          if (gameState.playerSide === 'left') {
            gameState.rightPaddle.y = data.paddleY;
          } else {
            gameState.leftPaddle.y = data.paddleY;
          }
        }
      });

      // Spielende
      socket.on('game_ended', (data) => {
        console.log('Spiel beendet:', data);
        gameState.gameActive = false;
        gameCanvas.style.cursor = 'default';
        
        if (data.reason === 'opponent_disconnected') {
          playerList.innerHTML = '<li class="empty">Gegner hat das Spiel verlassen</li>';
          gameInfo.textContent = 'Spiel beendet';
        }
      });

      // Spielen-Button
      playButton.addEventListener('click', () => {
        if (socket.connected) {
          gameState.playerName = prompt('Dein Spielername:', `Spieler_${Math.floor(Math.random()*1000)}`);
          const nameToSend = gameState.playerName || `Spieler_${socket.id.substr(0, 4)}`;
          
          socket.emit('join_queue', nameToSend);
          playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
          gameInfo.textContent = 'Verbinde...';
        } else {
          alert('Keine Serververbindung!');
        }
      });

      // Paddle-Bewegung
      gameCanvas.addEventListener('mousemove', (e) => {
        if (!gameState.gameActive) return;
        
        const rect = gameCanvas.getBoundingClientRect();
        const y = Math.max(0, Math.min(100, ((e.clientY - rect.top) / gameCanvas.height) * 100));
        
        // Eigenes Paddle bewegen
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        // Update an Server senden
        socket.emit('game_update', {
          gameId: gameState.currentGame,
          paddleY: y
        });
      });

      // Touch-Support
      gameCanvas.addEventListener('touchmove', (e) => {
        if (!gameState.gameActive) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const rect = gameCanvas.getBoundingClientRect();
        const y = Math.max(0, Math.min(100, ((touch.clientY - rect.top) / gameCanvas.height) * 100));
        
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        socket.emit('game_update', {
          gameId: gameState.currentGame,
          paddleY: y
        });
      });

      // Render-Funktion
      function render() {
        if (!gameState.gameActive) return;
        
        // Hintergrund
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        // Mittellinie
        ctx.setLineDash([15, 15]);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(gameCanvas.width/2, 0);
        ctx.lineTo(gameCanvas.width/2, gameCanvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Schl√§ger
        ctx.fillStyle = '#FFF';
        // Linker Schl√§ger
        ctx.fillRect(
          20, 
          (gameState.leftPaddle.y/100)*gameCanvas.height - gameState.leftPaddle.height/2, 
          gameState.leftPaddle.width, 
          gameState.leftPaddle.height
        );
        // Rechter Schl√§ger
        ctx.fillRect(
          gameCanvas.width - 20 - gameState.rightPaddle.width, 
          (gameState.rightPaddle.y/100)*gameCanvas.height - gameState.rightPaddle.height/2, 
          gameState.rightPaddle.width, 
          gameState.rightPaddle.height
        );
        
        // Ball
        ctx.beginPath();
        ctx.arc(
          (gameState.ball.x/100)*gameCanvas.width,
          (gameState.ball.y/100)*gameCanvas.height,
          gameState.ball.radius,
          0,
          Math.PI*2
        );
        ctx.fill();
        
        // Spielernamen anzeigen
        ctx.fillStyle = '#FFF';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(leftPlayerName.textContent, gameCanvas.width * 0.25, 30);
        ctx.fillText(rightPlayerName.textContent, gameCanvas.width * 0.75, 30);
        
        // Punktestand anzeigen
        ctx.font = '24px Arial';
        ctx.fillText(gameState.scores.left, gameCanvas.width * 0.25, 60);
        ctx.fillText(gameState.scores.right, gameCanvas.width * 0.75, 60);
      }
    });
  </script>
</body>
</html>
