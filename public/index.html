<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Pong | carnifexe-github-io.onrender.com</title>
  <style>
    :root {
      --primary: #4CAF50;
      --secondary: #2E7D32;
      --accent: #FFC107;
      --background: #121212;
      --surface: #1E1E1E;
      --error: #CF6679;
      --text-primary: #FFFFFF;
      --text-secondary: rgba(255, 255, 255, 0.7);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
    }

    h1 {
      color: var(--primary);
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }

    #connectionStatus {
      padding: 12px 20px;
      border-radius: 8px;
      margin: 10px 0;
      width: 100%;
      max-width: 800px;
      text-align: center;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .online {
      background-color: var(--secondary);
      border-left: 5px solid var(--primary);
    }

    .offline {
      background-color: #5c2a2a;
      border-left: 5px solid var(--error);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    #scoreBoard {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      margin: 10px 0;
      font-size: 1.5rem;
      font-weight: bold;
      background: var(--surface);
      padding: 10px 20px;
      border-radius: 8px;
    }

    #leftScore, #rightScore {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #gameCanvas {
      background: #000;
      border: 2px solid var(--surface);
      display: block;
      width: 800px;
      height: 600px;
      margin: 10px 0;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
      touch-action: none;
    }

    #playersPanel {
      width: 100%;
      max-width: 800px;
      margin: 20px 0;
      background: var(--surface);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #playersPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    #playerList {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #playerList li {
      padding: 12px 15px;
      margin: 8px 0;
      border-radius: 6px;
      transition: all 0.3s ease;
    }

    #playerList li.playing {
      background-color: rgba(76, 175, 80, 0.1);
      border-left: 3px solid var(--primary);
    }

    #playerList li.empty {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    #playButton {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
      transition: all 0.2s ease;
    }

    #playButton:hover {
      background-color: var(--secondary);
      transform: translateY(-2px);
    }

    #gameInfo {
      margin-top: 15px;
      font-size: 0.9rem;
      color: var(--accent);
      text-align: center;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(255, 193, 7, 0.1);
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      #gameCanvas {
        width: 100%;
        height: 400px;
      }
      
      #scoreBoard {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Ultimate Pong</h1>
    <div id="connectionStatus">üü° Verbinde mit Server...</div>
  </header>

  <main id="gameContainer">
    <div id="scoreBoard">
      <div id="leftScore"><span id="leftPlayerName">Du</span>: <span>0</span></div>
      <div id="rightScore"><span id="rightPlayerName">Gegner</span>: <span>0</span></div>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <section id="playersPanel">
      <h2>Spielstatus</h2>
      <ul id="playerList">
        <li class="empty">Verbinde mit Server...</li>
      </ul>
      <button id="playButton">Jetzt spielen</button>
      <div id="gameInfo">Bereit f√ºr ein Spiel?</div>
    </section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elemente
      const gameCanvas = document.getElementById('gameCanvas');
      const ctx = gameCanvas.getContext('2d');
      const playerList = document.getElementById('playerList');
      const connectionStatus = document.getElementById('connectionStatus');
      const playButton = document.getElementById('playButton');
      const gameInfo = document.getElementById('gameInfo');
      const leftScore = document.getElementById('leftScore').querySelector('span:last-child');
      const rightScore = document.getElementById('rightScore').querySelector('span:last-child');
      const leftPlayerName = document.getElementById('leftPlayerName');
      const rightPlayerName = document.getElementById('rightPlayerName');

      // Verbesserter Spielzustand mit Elementen aus beiden Codes
      const gameState = {
        leftPaddle: { y: 50, width: 2, height: 20, speed: 0, baseHeight: 20 },
        rightPaddle: { y: 50, width: 2, height: 20, speed: 0, baseHeight: 20 },
        ball: { 
          x: 50, 
          y: 50,
          radius: 1.5,
          speedX: 0,
          speedY: 0,
          baseSpeed: 0.5,
          lastUpdate: Date.now(),
          type: 'normal',
          color: '#FFFFFF'
        },
        scores: { left: 0, right: 0 },
        gameId: null,
        playerSide: null,
        opponentSide: null,
        opponentName: '',
        playerName: '',
        gameActive: false,
        isHost: false,
        powerUps: [],
        lastPowerUpSpawn: 0,
        lastRender: 0
      };

      // Physik Konstanten
      const PADDLE_HEIGHT = 20;
      const PADDLE_WIDTH = 2;
      const BALL_SIZE = 1.5;
      const BALL_SPEED = 0.5;
      const FIELD_WIDTH = 100;
      const FIELD_HEIGHT = 100;

      // Canvas Gr√∂√üe anpassen
      function resizeCanvas() {
        const ratio = 800/600;
        if (window.innerWidth < 800) {
          gameCanvas.width = window.innerWidth - 40;
          gameCanvas.height = gameCanvas.width / ratio;
        } else {
          gameCanvas.width = 800;
          gameCanvas.height = 600;
        }
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Verbesserte Socket.io Kommunikation
      const socket = io('wss://carnifexe-github-io.onrender.com', {
        transports: ['websocket'],
        reconnectionAttempts: 5,
        reconnectionDelay: 3000
      });

      // Verbindungsstatus
      socket.on('connect', () => {
        console.log('Verbunden mit Server:', socket.id);
        connectionStatus.innerHTML = 'üü¢ ONLINE';
        connectionStatus.className = 'online';
        gameInfo.textContent = 'Bereit zum Spielen';
      });

      socket.on('disconnect', (reason) => {
        console.log('Verbindung getrennt:', reason);
        connectionStatus.innerHTML = 'üî¥ OFFLINE';
        connectionStatus.className = 'offline';
        gameState.gameActive = false;
        gameInfo.textContent = 'Verbindung verloren';
      });

      socket.on('connect_error', (err) => {
        console.error('Verbindungsfehler:', err);
        gameInfo.textContent = 'Verbindungsfehler - versuche erneut...';
      });

      // Warteschlangen-Update
      socket.on('queue_update', (data) => {
        console.log('Warteschlangen-Update:', data);
        gameInfo.textContent = `Warteposition: ${data.position} (ca. ${data.estimatedWait}s)`;
        playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
      });

      // Spielstart mit initialer Synchronisation
      socket.on('game_start', (data) => {
        console.log('Spielstart:', data);
        gameState.gameId = data.gameId;
        gameState.playerSide = data.playerSide;
        gameState.opponentSide = data.opponentSide;
        gameState.opponentName = data.opponentName || `Spieler_${Math.floor(Math.random()*1000)}`;
        gameState.gameActive = true;
        gameState.isHost = data.playerSide === 'left';
        
        // Initialpositionen setzen
        gameState.ball.x = 50;
        gameState.ball.y = 50;
        gameState.ball.speedX = data.playerSide === 'left' ? BALL_SPEED : -BALL_SPEED;
        gameState.ball.speedY = 0;
        gameState.ball.baseSpeed = BALL_SPEED;
        
        // Spielernamen anzeigen
        leftPlayerName.textContent = data.playerSide === 'left' ? (gameState.playerName || 'Du') : data.opponentName;
        rightPlayerName.textContent = data.playerSide === 'right' ? (gameState.playerName || 'Du') : data.opponentName;
        
        // Scores aktualisieren
        leftScore.textContent = gameState.scores.left;
        rightScore.textContent = gameState.scores.right;
        
        playerList.innerHTML = `
          <li class="playing">
            Gegen ${data.opponentName}
            <span class="status">(${gameState.playerSide === 'left' ? 'Links' : 'Rechts'})</span>
          </li>
        `;
        
        gameCanvas.style.cursor = 'none';
        gameInfo.textContent = 'Spiel l√§uft!';
        
        startGameLoop();
      });

      // Paddle Updates vom Gegner
      socket.on('paddle_update', (data) => {
        if (gameState.gameId === data.gameId) {
          if (data.side === 'left') {
            gameState.leftPaddle.y = data.y;
          } else {
            gameState.rightPaddle.y = data.y;
          }
        }
      });

      // Ball Updates vom Host
      socket.on('ball_update', (data) => {
        if (gameState.gameId === data.gameId) {
          gameState.ball.x = data.x;
          gameState.ball.y = data.y;
          gameState.ball.speedX = data.speedX;
          gameState.ball.speedY = data.speedY;
          gameState.ball.lastUpdate = Date.now();
        }
      });

      // Score Updates
      socket.on('score_update', (data) => {
        if (gameState.gameId === data.gameId) {
          gameState.scores = data.scores;
          leftScore.textContent = gameState.scores.left;
          rightScore.textContent = gameState.scores.right;
        }
      });

      // PowerUp Updates
      socket.on('powerup_update', (data) => {
        if (gameState.gameId === data.gameId) {
          gameState.powerUps = data.powerUps;
        }
      });

      // Spielende
      socket.on('game_ended', (data) => {
        console.log('Spiel beendet:', data);
        gameState.gameActive = false;
        gameCanvas.style.cursor = 'default';
        
        if (data.reason === 'opponent_disconnected') {
          playerList.innerHTML = '<li class="empty">Gegner hat das Spiel verlassen</li>';
          gameInfo.textContent = 'Spiel beendet';
        }
      });

      // Verbesserte Spielschleife mit Elementen aus beiden Codes
      function startGameLoop() {
        let lastTime = performance.now();
        
        function gameLoop(timestamp) {
          if (!gameState.gameActive) return;
          
          const deltaTime = timestamp - lastTime;
          lastTime = timestamp;
          
          // Nur Host berechnet Ballphysik und PowerUps
          if (gameState.isHost) {
            updateBallPhysics(deltaTime);
            
            // PowerUps spawnen
            if (timestamp - gameState.lastPowerUpSpawn > 10000 && Math.random() < 0.01) {
              spawnPowerUp();
              gameState.lastPowerUpSpawn = timestamp;
            }
            
            // PowerUps aktualisieren
            updatePowerUps();
          }
          
          updatePaddles(deltaTime);
          render();
          requestAnimationFrame(gameLoop);
        }
        gameLoop(lastTime);
      }

      function spawnPowerUp() {
        const types = ['bigPaddle', 'smallPaddle', 'fastBall', 'slowBall'];
        const type = types[Math.floor(Math.random() * types.length)];
        
        gameState.powerUps.push({
          x: 10 + Math.random() * 80,
          y: 10 + Math.random() * 80,
          radius: 5,
          type: type,
          color: getPowerUpColor(type)
        });
        
        // Update an Server senden
        socket.emit('powerup_update', {
          gameId: gameState.gameId,
          powerUps: gameState.powerUps
        });
      }

      function getPowerUpColor(type) {
        switch(type) {
          case 'bigPaddle': return '#4CAF50';
          case 'smallPaddle': return '#F44336';
          case 'fastBall': return '#FFC107';
          case 'slowBall': return '#2196F3';
          default: return '#FFFFFF';
        }
      }

      function updatePowerUps() {
        // PowerUps mit Ball kollidieren
        gameState.powerUps = gameState.powerUps.filter(powerUp => {
          const distance = Math.sqrt(
            Math.pow(gameState.ball.x - powerUp.x, 2) + 
            Math.pow(gameState.ball.y - powerUp.y, 2)
          );
          
          if (distance < gameState.ball.radius + powerUp.radius) {
            activatePowerUp(powerUp.type);
            return false;
          }
          return true;
        });
      }

      function activatePowerUp(type) {
        // PowerUp Effekte
        switch(type) {
          case 'bigPaddle':
            if (gameState.playerSide === 'left') {
              gameState.leftPaddle.height = gameState.leftPaddle.baseHeight * 1.5;
            } else {
              gameState.rightPaddle.height = gameState.rightPaddle.baseHeight * 1.5;
            }
            setTimeout(resetPaddles, 5000);
            break;
            
          case 'smallPaddle':
            if (gameState.playerSide === 'left') {
              gameState.rightPaddle.height = gameState.rightPaddle.baseHeight * 0.7;
            } else {
              gameState.leftPaddle.height = gameState.leftPaddle.baseHeight * 0.7;
            }
            setTimeout(resetPaddles, 5000);
            break;
            
          case 'fastBall':
            gameState.ball.speedX *= 1.5;
            gameState.ball.speedY *= 1.5;
            setTimeout(() => {
              gameState.ball.speedX = Math.sign(gameState.ball.speedX) * gameState.ball.baseSpeed;
              gameState.ball.speedY = Math.sign(gameState.ball.speedY) * gameState.ball.baseSpeed;
            }, 5000);
            break;
            
          case 'slowBall':
            gameState.ball.speedX *= 0.5;
            gameState.ball.speedY *= 0.5;
            setTimeout(() => {
              gameState.ball.speedX = Math.sign(gameState.ball.speedX) * gameState.ball.baseSpeed;
              gameState.ball.speedY = Math.sign(gameState.ball.speedY) * gameState.ball.baseSpeed;
            }, 5000);
            break;
        }
      }

      function resetPaddles() {
        gameState.leftPaddle.height = gameState.leftPaddle.baseHeight;
        gameState.rightPaddle.height = gameState.rightPaddle.baseHeight;
      }

      // Pr√§zise Ballphysik aus dem ersten Code
      function updateBallPhysics(deltaTime) {
        const timeFactor = deltaTime / 16;
        
        // Ball bewegen
        gameState.ball.x += gameState.ball.speedX * timeFactor;
        gameState.ball.y += gameState.ball.speedY * timeFactor;
        
        // Wandkollision oben/unten
        if (gameState.ball.y - gameState.ball.radius <= 0 || gameState.ball.y + gameState.ball.radius >= FIELD_HEIGHT) {
          gameState.ball.speedY *= -1;
          gameState.ball.y = Math.max(gameState.ball.radius, Math.min(FIELD_HEIGHT - gameState.ball.radius, gameState.ball.y));
        }
        
        // Paddle Kollision links
        if (gameState.ball.x - gameState.ball.radius <= 5 + PADDLE_WIDTH && 
            gameState.ball.y >= gameState.leftPaddle.y - gameState.leftPaddle.height/2 &&
            gameState.ball.y <= gameState.leftPaddle.y + gameState.leftPaddle.height/2) {
          
          // Trefferposition berechnen (-0.5 bis 0.5)
          const hitPos = (gameState.ball.y - gameState.leftPaddle.y) / gameState.leftPaddle.height;
          
          gameState.ball.speedX = Math.abs(gameState.ball.speedX);
          gameState.ball.speedY = hitPos * 2; // Winkel basierend auf Trefferposition
          
          // Ball nach rechts setzen
          gameState.ball.x = 5 + PADDLE_WIDTH + gameState.ball.radius;
        }
        
        // Paddle Kollision rechts
        if (gameState.ball.x + gameState.ball.radius >= 95 - PADDLE_WIDTH && 
            gameState.ball.y >= gameState.rightPaddle.y - gameState.rightPaddle.height/2 &&
            gameState.ball.y <= gameState.rightPaddle.y + gameState.rightPaddle.height/2) {
          
          const hitPos = (gameState.ball.y - gameState.rightPaddle.y) / gameState.rightPaddle.height;
          
          gameState.ball.speedX = -Math.abs(gameState.ball.speedX);
          gameState.ball.speedY = hitPos * 2;
          
          gameState.ball.x = 95 - PADDLE_WIDTH - gameState.ball.radius;
        }
        
        // Punkte
        if (gameState.ball.x < 0 || gameState.ball.x > FIELD_WIDTH) {
          if (gameState.ball.x < 0) {
            gameState.scores.right++;
          } else {
            gameState.scores.left++;
          }
          
          // Ball zur√ºcksetzen
          resetBall();
          
          // Scores aktualisieren
          socket.emit('score_update', {
            gameId: gameState.gameId,
            scores: gameState.scores
          });
        }
        
        // Ball Update senden
        socket.emit('ball_update', {
          gameId: gameState.gameId,
          x: gameState.ball.x,
          y: gameState.ball.y,
          speedX: gameState.ball.speedX,
          speedY: gameState.ball.speedY
        });
      }

      function resetBall() {
        gameState.ball.x = 50;
        gameState.ball.y = 50;
        gameState.ball.speedX = (Math.random() > 0.5 ? 1 : -1) * gameState.ball.baseSpeed;
        gameState.ball.speedY = (Math.random() * 2 - 1) * gameState.ball.baseSpeed;
        gameState.powerUps = [];
      }

      // Paddle Bewegung
      function updatePaddles(deltaTime) {
        // Eigene Paddle-Bewegung
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y += gameState.leftPaddle.speed * (deltaTime / 16);
        } else {
          gameState.rightPaddle.y += gameState.rightPaddle.speed * (deltaTime / 16);
        }
        
        // Paddle im Feld halten
        gameState.leftPaddle.y = Math.max(gameState.leftPaddle.height/2, Math.min(FIELD_HEIGHT - gameState.leftPaddle.height/2, gameState.leftPaddle.y));
        gameState.rightPaddle.y = Math.max(gameState.rightPaddle.height/2, Math.min(FIELD_HEIGHT - gameState.rightPaddle.height/2, gameState.rightPaddle.y));
      }

      // Input Handling
      gameCanvas.addEventListener('mousemove', (e) => {
        if (!gameState.gameActive) return;
        
        const rect = gameCanvas.getBoundingClientRect();
        const y = (e.clientY - rect.top) / gameCanvas.height * FIELD_HEIGHT;
        
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        // Paddle Update senden
        socket.emit('paddle_update', {
          gameId: gameState.gameId,
          side: gameState.playerSide,
          y: y
        });
      });

      gameCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!gameState.gameActive) return;
        
        const touch = e.touches[0];
        const rect = gameCanvas.getBoundingClientRect();
        const y = (touch.clientY - rect.top) / gameCanvas.height * FIELD_HEIGHT;
        
        if (gameState.playerSide === 'left') {
          gameState.leftPaddle.y = y;
        } else {
          gameState.rightPaddle.y = y;
        }
        
        // Paddle Update senden
        socket.emit('paddle_update', {
          gameId: gameState.gameId,
          side: gameState.playerSide,
          y: y
        });
      }, { passive: false });

      // Render-Funktion mit Elementen aus beiden Codes
      function render() {
        // Clear canvas
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        // Mittellinie
        ctx.strokeStyle = '#333';
        ctx.setLineDash([15, 15]);
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(gameCanvas.width/2, 0);
        ctx.lineTo(gameCanvas.width/2, gameCanvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Schl√§ger
        ctx.fillStyle = '#FFF';
        // Linker Schl√§ger
        ctx.fillRect(
          0.05 * gameCanvas.width,
          (gameState.leftPaddle.y/FIELD_HEIGHT) * gameCanvas.height - gameState.leftPaddle.height/200 * gameCanvas.height,
          PADDLE_WIDTH/100 * gameCanvas.width,
          gameState.leftPaddle.height/100 * gameCanvas.height
        );
        // Rechter Schl√§ger
        ctx.fillRect(
          0.95 * gameCanvas.width - PADDLE_WIDTH/100 * gameCanvas.width,
          (gameState.rightPaddle.y/FIELD_HEIGHT) * gameCanvas.height - gameState.rightPaddle.height/200 * gameCanvas.height,
          PADDLE_WIDTH/100 * gameCanvas.width,
          gameState.rightPaddle.height/100 * gameCanvas.height
        );
        
        // PowerUps zeichnen
        gameState.powerUps.forEach(powerUp => {
          ctx.fillStyle = powerUp.color;
          ctx.beginPath();
          ctx.arc(
            (powerUp.x/FIELD_WIDTH)*gameCanvas.width,
            (powerUp.y/FIELD_HEIGHT)*gameCanvas.height,
            powerUp.radius * 2,
            0,
            Math.PI*2
          );
          ctx.fill();
        });
        
        // Ball
        ctx.fillStyle = gameState.ball.color;
        ctx.beginPath();
        ctx.arc(
          (gameState.ball.x/FIELD_WIDTH) * gameCanvas.width,
          (gameState.ball.y/FIELD_HEIGHT) * gameCanvas.height,
          gameState.ball.radius/100 * gameCanvas.width,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        // Spielernamen anzeigen
        ctx.fillStyle = '#FFF';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(leftPlayerName.textContent, gameCanvas.width * 0.25, 30);
        ctx.fillText(rightPlayerName.textContent, gameCanvas.width * 0.75, 30);
        
        // Scores
        ctx.font = '24px Arial';
        ctx.fillText(gameState.scores.left, gameCanvas.width * 0.25, 60);
        ctx.fillText(gameState.scores.right, gameCanvas.width * 0.75, 60);
      }

      // Spieler verbinden
      playButton.addEventListener('click', () => {
        gameState.playerName = prompt('Dein Spielername:', `Spieler_${Math.floor(Math.random()*1000)}`);
        const nameToSend = gameState.playerName || `Spieler_${socket.id.substr(0, 4)}`;
        socket.emit('join_queue', nameToSend);
        playerList.innerHTML = '<li class="empty">Suche nach Gegner...</li>';
        gameInfo.textContent = 'Verbinde...';
      });
    });
  </script>
</body>
</html>
