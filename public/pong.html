<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong Multiplayer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      display: none;
      background: #000;
    }
    #queueButton {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 20px;
      cursor: pointer;
      z-index: 10001;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
    }
    #waitingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 10002;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #readyScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 10003;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 72px;
      font-weight: bold;
    }
    #queueStatus {
      font-size: 24px;
      margin-top: 20px;
    }
    #playerCount {
      font-size: 18px;
      margin-top: 10px;
      color: #aaa;
    }
    #scoreboard {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      z-index: 10004;
      display: none;
      background: rgba(0,0,0,0.5);
      padding: 10px 20px;
      border-radius: 5px;
    }
    .teams-container {
      display: flex;
      gap: 40px;
    }
    .team {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .team-name {
      font-size: 18px;
      color: #aaa;
    }
    .team-score {
      font-size: 32px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="waitingScreen">
    <h1>Pong Multiplayer</h1>
    <button id="queueButton">Warteschlange betreten</button>
    <div id="queueStatus">Nicht in Warteschlange</div>
    <div id="playerCount">0 Spieler in Warteschlange</div>
  </div>

  <div id="readyScreen">
    <div id="countdown">Ready...</div>
  </div>

  <div id="scoreboard">
    <div class="teams-container">
      <div class="team">
        <div class="team-name">Spieler 1</div>
        <div class="team-score" id="player1Score">0</div>
      </div>
      <div class="team">
        <div class="team-name">Spieler 2</div>
        <div class="team-score" id="player2Score">0</div>
      </div>
    </div>
  </div>
  <canvas id="pongCanvas"></canvas>

  <!-- Sound-Elemente -->
  <audio id="pingSound" src="https://assets.mixkit.co/sfx/preview/mixkit-retro-game-notification-212.mp3" preload="auto"></audio>
  <audio id="pongSound" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" preload="auto"></audio>
  <audio id="saHPSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>
  <audio id="lsSound" src="https://assets.mixkit.co/sfx/preview/mixkit-basketball-ball-bouncing-2085.mp3" preload="auto"></audio>
  <audio id="bounceSound" src="https://assets.mixkit.co/sfx/preview/mixkit-quick-jump-arcade-game-239.mp3" preload="auto"></audio>
  <audio id="winnerSound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
  <audio id="powerupSound" src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3" preload="auto"></audio>

  <script>
    // 1. Initialisierung
    const socket = new WebSocket('wss://carnifexe-github-io.onrender.com');
    const canvas = document.getElementById("pongCanvas");
    const ctx = canvas.getContext("2d");
    const queueButton = document.getElementById("queueButton");
    const waitingScreen = document.getElementById("waitingScreen");
    const readyScreen = document.getElementById("readyScreen");
    const queueStatus = document.getElementById("queueStatus");
    const playerCount = document.getElementById("playerCount");
    const countdown = document.getElementById("countdown");
    const scoreboard = document.getElementById("scoreboard");
    const player1ScoreElement = document.getElementById("player1Score");
    const player2ScoreElement = document.getElementById("player2Score");

    // Sound-Elemente
    const pingSound = document.getElementById("pingSound");
    const pongSound = document.getElementById("pongSound");
    const saHPSound = document.getElementById("saHPSound");
    const lsSound = document.getElementById("lsSound");
    const bounceSound = document.getElementById("bounceSound");
    const winnerSound = document.getElementById("winnerSound");
    const powerupSound = document.getElementById("powerupSound");

    // Sound stoppen Funktionen
    function stopNonGoalSounds() {
        [pingSound, pongSound, bounceSound, powerupSound].forEach(sound => {
            sound.pause();
            sound.currentTime = 0;
        });
    }

    function stopAllSounds() {
        [pingSound, pongSound, saHPSound, lsSound, bounceSound, powerupSound, winnerSound].forEach(sound => {
            sound.pause();
            sound.currentTime = 0;
        });
    }

    // 2. Spielvariablen
    let gameRunning = false;
    let playerNumber = null;
    let isHost = false;
    let inQueue = false;
    
    // Pong-Elemente
    const basePaddleWidth = 15;
    const basePaddleHeight = 100;
    const ballSize = 10;
    let player1Y = canvas.height / 2 - basePaddleHeight / 2;
    let player2Y = canvas.height / 2 - basePaddleHeight / 2;
    let ballX = canvas.width / 2;
    let ballY = canvas.height / 2;
    let ballSpeedX = 5;
    let ballSpeedY = 5;
    let player1Score = 0;
    let player2Score = 0;
    let ballTrail = [];
    const maxTrailLength = 5;
    
    // Schläger-Modifikatoren
    let leftPaddleMultiplier = 1.0;
    let rightPaddleMultiplier = 1.0;
    const maxPaddleMultiplier = 2.0;
    const paddleIncreasePerGoal = 0.2;

    // Spezielle Bälle Eigenschaften
    const SPECIAL_BALLS = {
        FIRE: {
            name: "fire",
            color: "#ff0000",
            speedMultiplier: 1.25,
            sizeMultiplier: 1,
            randomDirection: false,
            doublePoints: false
        },
        ICE: {
            name: "ice",
            color: "#ffffff",
            speedMultiplier: 0.8,
            sizeMultiplier: 1,
            randomDirection: true,
            doublePoints: false
        },
        EARTH: {
            name: "earth",
            color: "#8B4513",
            speedMultiplier: 0.85,
            sizeMultiplier: 2,
            randomDirection: false,
            doublePoints: false
        },
        PLASMA: {
            name: "plasma",
            color: "#9400D3",
            speedMultiplier: 1,
            sizeMultiplier: 1,
            randomDirection: true,
            doublePoints: false
        },
        GOLD: {
            name: "gold",
            color: "#FFD700",
            speedMultiplier: 2,
            sizeMultiplier: 0.5,
            randomDirection: false,
            doublePoints: true
        }
    };

    let currentSpecialBall = null;

    // 3. Canvas Setup
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      resetGame();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // 4. WebSocket-Handler
    socket.onopen = () => {
      console.log("Mit Server verbunden");
    };

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log("Empfangen:", data);

      if (data.type === "queueUpdate") {
        playerCount.textContent = `${data.count} Spieler in Warteschlange`;
        if (data.count === 2 && inQueue) {
          startCountdown();
        }
      }

      if (data.type === "gameStart") {
        playerNumber = data.playerNumber;
        isHost = data.playerNumber === 1;
        scoreboard.style.display = "flex";
      }

      if (data.type === "paddleMove") {
        if (data.player === 1) player1Y = data.y;
        if (data.player === 2) player2Y = data.y;
      }

      if (data.type === "ballUpdate") {
        ballX = data.x;
        ballY = data.y;
        ballSpeedX = data.speedX;
        ballSpeedY = data.speedY;
        if (data.specialBall) {
          currentSpecialBall = SPECIAL_BALLS[data.specialBall];
        } else {
          currentSpecialBall = null;
        }
      }

      if (data.type === "scoreUpdate") {
        player1Score = data.player1;
        player2Score = data.player2;
        leftPaddleMultiplier = data.leftPaddleMultiplier;
        rightPaddleMultiplier = data.rightPaddleMultiplier;
        updateScoreboard();
        
        if (player1Score >= 10 || player2Score >= 10) {
          gameRunning = false;
          if ((playerNumber === 1 && player1Score >= 10) || (playerNumber === 2 && player2Score >= 10)) {
            winnerSound.play();
            alert("Du hast gewonnen!");
          } else {
            alert("Du hast verloren!");
          }
          location.reload();
        }
      }

      if (data.type === "paddleSizeUpdate") {
        leftPaddleMultiplier = data.leftPaddleMultiplier;
        rightPaddleMultiplier = data.rightPaddleMultiplier;
      }

      if (data.type === "opponentDisconnected") {
        alert("Dein Gegner hat das Spiel verlassen!");
        location.reload();
      }

      if (data.type === "playSound") {
        if (data.sound === "ping") pingSound.play();
        if (data.sound === "pong") pongSound.play();
        if (data.sound === "bounce") bounceSound.play();
        if (data.sound === "powerup") powerupSound.play();
      }
    };

    // 5. Warteschlangen-Logik
    queueButton.addEventListener("click", () => {
      if (!inQueue) {
        socket.send(JSON.stringify({ type: "joinQueue" }));
        queueButton.textContent = "Warteschlange verlassen";
        queueStatus.textContent = "In Warteschlange...";
        queueStatus.style.color = "#FFA500";
        inQueue = true;
      } else {
        socket.send(JSON.stringify({ type: "leaveQueue" }));
        queueButton.textContent = "Warteschlange betreten";
        queueStatus.textContent = "Nicht in Warteschlange";
        queueStatus.style.color = "white";
        inQueue = false;
      }
    });

    // 6. Countdown-Logik
    function startCountdown() {
      waitingScreen.style.display = "none";
      readyScreen.style.display = "flex";
      
      let counter = 3;
      countdown.textContent = "Ready...";
      
      const countdownInterval = setInterval(() => {
        if (counter > 0) {
          countdown.textContent = counter;
          counter--;
        } else {
          clearInterval(countdownInterval);
          countdown.textContent = "GO!";
          setTimeout(() => {
            readyScreen.style.display = "none";
            startGame();
          }, 500);
        }
      }, 1000);
    }

    // 7. Spielsteuerung per Maus
    document.addEventListener('mousemove', (e) => {
      if (!gameRunning) return;
      let newY = e.clientY - (basePaddleHeight * (playerNumber === 1 ? leftPaddleMultiplier : rightPaddleMultiplier)) / 2;
      newY = Math.max(0, Math.min(canvas.height - (basePaddleHeight * (playerNumber === 1 ? leftPaddleMultiplier : rightPaddleMultiplier)), newY));

      if (playerNumber === 1) {
        player1Y = newY;
        socket.send(JSON.stringify({ 
          type: "paddleMove", 
          player: 1, 
          y: player1Y 
        }));
      } else if (playerNumber === 2) {
        player2Y = newY;
        socket.send(JSON.stringify({ 
          type: "paddleMove", 
          player: 2, 
          y: player2Y 
        }));
      }
    });

    // 8. Spiel-Logik
    function resetGame() {
      ballX = canvas.width / 2;
      ballY = canvas.height / 2;
      ballSpeedX = 5 * (Math.random() > 0.5 ? 1 : -1);
      ballSpeedY = 5 * (Math.random() > 0.5 ? 1 : -1);
      ballTrail = [];
      
      if (Math.random() < 0.2 && isHost) {
        const specialBalls = Object.values(SPECIAL_BALLS);
        currentSpecialBall = specialBalls[Math.floor(Math.random() * specialBalls.length)];
        socket.send(JSON.stringify({
          type: "ballUpdate",
          specialBall: Object.keys(SPECIAL_BALLS).find(key => SPECIAL_BALLS[key] === currentSpecialBall)
        }));
      } else {
        currentSpecialBall = null;
      }
    }

    function updateScoreboard() {
      player1ScoreElement.textContent = player1Score;
      player2ScoreElement.textContent = player2Score;
    }

    function drawCenterLine() {
      ctx.strokeStyle = "#333";
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function clearCanvas() {
      // Klarer Hintergrund ohne Motion-Blur-Spuren
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawBall() {
      // Ball-Spur mit weichem Verlauf
      for (let i = 0; i < ballTrail.length; i++) {
        const alpha = (i / ballTrail.length) * 0.8;
        const size = ballSize * (1 - i / (ballTrail.length * 1.8));
        
        ctx.beginPath();
        ctx.arc(ballTrail[i].x, ballTrail[i].y, size, 0, Math.PI * 2);
        
        const gradient = ctx.createRadialGradient(
          ballTrail[i].x, ballTrail[i].y, 0,
          ballTrail[i].x, ballTrail[i].y, size
        );
        
        if (currentSpecialBall) {
          gradient.addColorStop(0, currentSpecialBall.color);
          gradient.addColorStop(1, "rgba(255,255,255,0)");
        } else {
          gradient.addColorStop(0, "rgba(255,255,255,0.8)");
          gradient.addColorStop(1, "rgba(255,255,100,0)");
        }
        
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.closePath();
      }
      
      // Hauptball mit Glow-Effekt
      const glowSize = ballSize + 5;
      const gradient = ctx.createRadialGradient(
        ballX, ballY, 0,
        ballX, ballY, glowSize
      );
      
      if (currentSpecialBall) {
        gradient.addColorStop(0, currentSpecialBall.color);
        gradient.addColorStop(0.7, currentSpecialBall.color);
        gradient.addColorStop(1, "rgba(255,255,255,0)");
      } else {
        gradient.addColorStop(0, "rgba(255,255,255,1)");
        gradient.addColorStop(0.7, "rgba(255,255,200,0.7)");
        gradient.addColorStop(1, "rgba(255,255,0,0)");
      }
      
      ctx.beginPath();
      ctx.arc(ballX, ballY, glowSize, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.closePath();
      
      // Kern des Balls
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballSize, 0, Math.PI * 2);
      ctx.fillStyle = currentSpecialBall ? currentSpecialBall.color : "white";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddles() {
      ctx.fillStyle = "#fff";
      // Linker Schläger
      ctx.fillRect(
        0, 
        player1Y, 
        basePaddleWidth, 
        basePaddleHeight * leftPaddleMultiplier
      );
      
      // Rechter Schläger
      ctx.fillRect(
        canvas.width - basePaddleWidth, 
        player2Y, 
        basePaddleWidth, 
        basePaddleHeight * rightPaddleMultiplier
      );
    }

    function gameLoop() {
      if (!gameRunning) return;
      
      // Ball-Spur aktualisieren
      ballTrail.push({x: ballX, y: ballY});
      if (ballTrail.length > maxTrailLength) {
        ballTrail.shift();
      }
      
      // Nur der Host berechnet die Ballphysik
      if (isHost) {
        const speedMultiplier = currentSpecialBall ? currentSpecialBall.speedMultiplier : 1;
        ballX += ballSpeedX * speedMultiplier;
        ballY += ballSpeedY * speedMultiplier;
        
        // Kollision mit Wänden
        if (ballY <= ballSize || ballY >= canvas.height - ballSize) {
          ballSpeedY = -ballSpeedY;
          socket.send(JSON.stringify({ type: "playSound", sound: "bounce" }));
        }
        
        // Kollision mit Paddles
        if (ballX <= basePaddleWidth + ballSize && 
            ballY >= player1Y && 
            ballY <= player1Y + (basePaddleHeight * leftPaddleMultiplier)) {
          ballSpeedX = -ballSpeedX * 1.05;
          socket.send(JSON.stringify({ type: "playSound", sound: "ping" }));
          
          if (Math.random() < 0.2) {
            const specialBalls = Object.values(SPECIAL_BALLS);
            currentSpecialBall = specialBalls[Math.floor(Math.random() * specialBalls.length)];
            socket.send(JSON.stringify({
              type: "ballUpdate",
              specialBall: Object.keys(SPECIAL_BALLS).find(key => SPECIAL_BALLS[key] === currentSpecialBall)
            }));
          }
        }
        
        if (ballX >= canvas.width - basePaddleWidth - ballSize && 
            ballY >= player2Y && 
            ballY <= player2Y + (basePaddleHeight * rightPaddleMultiplier)) {
          ballSpeedX = -ballSpeedX * 1.05;
          socket.send(JSON.stringify({ type: "playSound", sound: "pong" }));
          
          if (Math.random() < 0.2) {
            const specialBalls = Object.values(SPECIAL_BALLS);
            currentSpecialBall = specialBalls[Math.floor(Math.random() * specialBalls.length)];
            socket.send(JSON.stringify({
              type: "ballUpdate",
              specialBall: Object.keys(SPECIAL_BALLS).find(key => SPECIAL_BALLS[key] === currentSpecialBall)
            }));
          }
        }
        
        // Punkte zählen
        if (ballX < 0) {
          // Spieler 2 (rechts) macht ein Tor
          const pointsToAdd = currentSpecialBall?.doublePoints ? 2 : 1;
          player2Score += pointsToAdd;
          
          rightPaddleMultiplier = 1.0;
          leftPaddleMultiplier = Math.min(leftPaddleMultiplier + paddleIncreasePerGoal, maxPaddleMultiplier);
          
          socket.send(JSON.stringify({
            type: "scoreUpdate",
            player1: player1Score,
            player2: player2Score,
            leftPaddleMultiplier: leftPaddleMultiplier,
            rightPaddleMultiplier: rightPaddleMultiplier
          }));
          
          socket.send(JSON.stringify({ type: "playSound", sound: "ls" }));
          powerupSound.play();
          resetGame();
        }
        
        if (ballX > canvas.width) {
          // Spieler 1 (links) macht ein Tor
          const pointsToAdd = currentSpecialBall?.doublePoints ? 2 : 1;
          player1Score += pointsToAdd;
          
          leftPaddleMultiplier = 1.0;
          rightPaddleMultiplier = Math.min(rightPaddleMultiplier + paddleIncreasePerGoal, maxPaddleMultiplier);
          
          socket.send(JSON.stringify({
            type: "scoreUpdate",
            player1: player1Score,
            player2: player2Score,
            leftPaddleMultiplier: leftPaddleMultiplier,
            rightPaddleMultiplier: rightPaddleMultiplier
          }));
          
          socket.send(JSON.stringify({ type: "playSound", sound: "saHP" }));
          powerupSound.play();
          resetGame();
        }
        
        // Ballposition an Gegner senden
        socket.send(JSON.stringify({
          type: "ballUpdate",
          x: ballX,
          y: ballY,
          speedX: ballSpeedX,
          speedY: ballSpeedY,
          specialBall: currentSpecialBall ? Object.keys(SPECIAL_BALLS).find(key => SPECIAL_BALLS[key] === currentSpecialBall) : null
        }));
      }
      
      clearCanvas();
      drawCenterLine();
      drawPaddles();
      drawBall();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      gameRunning = true;
      canvas.style.display = "block";
      
      // Initialisierung
      player1Score = 0;
      player2Score = 0;
      leftPaddleMultiplier = 1.0;
      rightPaddleMultiplier = 1.0;
      
      resetGame();
      updateScoreboard();
      gameLoop();
    }
  </script>
</body>
</html>
