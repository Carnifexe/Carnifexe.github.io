<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong Multiplayer</title>
  <style>
    /* [Alle CSS-Stile bleiben gleich] */
  </style>
</head>
<body>
  <!-- [HTML-Struktur bleibt gleich] -->

  <script>
    // Initialisierung
    const socket = new WebSocket('wss://carnifexe-github-io.onrender.com');
    const canvas = document.getElementById("pongCanvas");
    const ctx = canvas.getContext("2d");
    const WINNING_SCORE = 10;
    const BALL_BASE_SPEED = 8;
    const LOCAL_BALL_SPEED = BALL_BASE_SPEED * 0.8;
    const NETWORK_UPDATE_RATE = 30;
    const INTERPOLATION_BUFFER_SIZE = 10;
    const SYNC_INTERVAL = 5000;

    // [UI Elemente und Basisvariablen bleiben gleich]

    // Physik-Variablen
    let lastFrameTime = 0;
    let ballSpeedMultiplier = 1.0;
    let lastBallUpdate = 0;

    // Zeit-Synchronisation
    function synchronizeClocks() {
      const start = Date.now();
      socket.send(JSON.stringify({
        type: "syncRequest",
        clientTime: start
      }));
      lastSyncTime = start;
    }

    // Ball-Interpolation mit Server-Zeit (NEU: verbesserte Version)
    function interpolateBall() {
      const now = Date.now() - clientClockOffset;
      
      // Finde die zwei neuesten Zustände
      if (ballStateBuffer.length > 0) {
        const latestState = ballStateBuffer[ballStateBuffer.length - 1];
        
        // Wenn der Zustand neu ist, aktualisiere die Ballposition
        if (latestState.timestamp > lastBallUpdate) {
          const timeDiff = now - latestState.timestamp;
          const predictionFactor = Math.max(0, Math.min(timeDiff / 100, 1)); // Max 100ms Vorhersage
          
          ballX = latestState.ballX + latestState.ballSpeedX * predictionFactor;
          ballY = latestState.ballY + latestState.ballSpeedY * predictionFactor;
          ballSpeedX = latestState.ballSpeedX;
          ballSpeedY = latestState.ballSpeedY;
          
          lastBallUpdate = latestState.timestamp;
        }
      }
      
      // Halte Puffer sauber
      if (ballStateBuffer.length > INTERPOLATION_BUFFER_SIZE) {
        ballStateBuffer.shift();
      }
    }

    // [initCanvas, resetBall, drawGame bleiben gleich]

    // Spiel aktualisieren (NEU: verbesserte Client-Handling)
    function updateGame(timestamp) {
      if (!gameRunning) return;

      const deltaTime = (timestamp - lastFrameTime) / 1000;
      lastFrameTime = timestamp;

      if (isHost || localMode) {
        // Host-Logik bleibt gleich
        // [Behalte bestehende Host-Logik bei]
      } else {
        // CLIENT-LOGIK (NEU): Aktiviere Ballbewegung
        interpolateBall();
        
        // Bewege Ball basierend auf aktueller Geschwindigkeit
        ballX += ballSpeedX * deltaTime * 60;
        ballY += ballSpeedY * deltaTime * 60;
        
        // Grenzkollisionen (nur visuell, keine Punktvergabe)
        if (ballY <= 0 || ballY >= canvas.height) {
          ballSpeedY = -ballSpeedY;
        }
      }

      // [Rest der Update-Logik bleibt gleich]
    }

    // [gameLoop, startCountdown, startGame, resetGame bleiben gleich]

    // WebSocket Nachrichten (NEU: verbesserte State-Verarbeitung)
    socket.onmessage = (event) => {
      if (localMode) return;

      const data = JSON.parse(event.data);

      if (data.type === "syncResponse") {
        clientClockOffset = Date.now() - ((data.clientTime + data.serverTime) / 2);
      }
      else if (data.type === "gameState") {
        // NEU: Sofortige Ballpositionierung bei neuem State
        if (ballStateBuffer.length === 0 || data.timestamp > ballStateBuffer[ballStateBuffer.length-1].timestamp) {
          ballStateBuffer.push({
            ballX: data.ballX,
            ballY: data.ballY,
            ballSpeedX: data.ballSpeedX,
            ballSpeedY: data.ballSpeedY,
            timestamp: data.timestamp
          });
          
          // Sofortige Aktualisierung für flüssigere Bewegung
          if (!isHost) {
            ballX = data.ballX;
            ballY = data.ballY;
            ballSpeedX = data.ballSpeedX;
            ballSpeedY = data.ballSpeedY;
          }
        }
      }
      // [Rest der Nachrichtenverarbeitung bleibt gleich]
    };

    // [Rest des Codes bleibt gleich]
  </script>
</body>
</html>
