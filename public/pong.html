<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong Multiplayer</title>
  <style>
    /* [Behalten Sie alle vorhandenen Stile bei] */
  </style>
</head>
<body>
  <!-- [Behalten Sie die gesamte HTML-Struktur bei] -->

  <script>
    // ============== INITIALISIERUNG ==============
    const socket = new WebSocket('wss://carnifexe-github-io.onrender.com');
    const canvas = document.getElementById("pongCanvas");
    const ctx = canvas.getContext("2d");
    const WINNING_SCORE = 10;
    const BALL_BASE_SPEED = 8;
    const PADDLE_WIDTH = 15;
    const PADDLE_HEIGHT = 100;
    const NETWORK_UPDATE_RATE = 30;
    const INTERPOLATION_BUFFER_SIZE = 10;
    const SYNC_INTERVAL = 5000;

    // UI Elemente
    const ui = {
      gameContainer: document.getElementById("gameContainer"),
      queueButton: document.getElementById("queueButton"),
      waitingScreen: document.getElementById("waitingScreen"),
      readyScreen: document.getElementById("readyScreen"),
      scoreboard: document.getElementById("scoreboard"),
      totalPlayers: document.getElementById("totalPlayers"),
      playerCount: document.getElementById("playerCount"),
      queueStatus: document.getElementById("queueStatus"),
      localTestBtn: document.getElementById("localTestBtn"),
      testControls: document.getElementById("testControls"),
      controlPlayer1: document.getElementById("controlPlayer1"),
      controlPlayer2: document.getElementById("controlPlayer2"),
      player1Score: document.getElementById("player1Score"),
      player2Score: document.getElementById("player2Score")
    };

    // Spielzustand
    const game = {
      running: false,
      localMode: false,
      testMode: false,
      inQueue: false,
      playerNumber: null,
      isHost: false,
      controlledPlayer: 0,
      lastUpdate: 0,
      clockOffset: 0,
      ballStateBuffer: [],
      lastNetworkUpdate: 0,
      lastSyncTime: 0,
      lastFrameTime: 0,
      canvasSize: { width: 0, height: 0 },
      ball: { x: 0, y: 0, speedX: 0, speedY: 0, multiplier: 1.0 },
      players: [
        { y: 0, score: 0 },
        { y: 0, score: 0 }
      ]
    };

    // ============== VERBINDUNGSHANDLING ==============
    socket.onopen = () => {
      console.log('Verbindung hergestellt');
      ui.queueButton.disabled = false;
      ui.queueStatus.textContent = "Verbunden - Bereit";
      synchronizeClocks();
    };

    socket.onerror = (error) => {
      console.error('WebSocket Fehler:', error);
      ui.queueStatus.textContent = "Verbindungsfehler";
      ui.queueButton.disabled = true;
    };

    socket.onclose = () => {
      console.log('Verbindung geschlossen');
      ui.queueStatus.textContent = "Getrennt";
      ui.queueButton.disabled = true;
      setTimeout(() => location.reload(), 5000);
    };

    // ============== SPIELFUNKTIONEN ==============
    function initCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      game.canvasSize = { width: canvas.width, height: canvas.height };
      game.players[0].y = canvas.height / 2 - PADDLE_HEIGHT / 2;
      game.players[1].y = canvas.height / 2 - PADDLE_HEIGHT / 2;
      resetBall();
    }

    function resetBall() {
      game.ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        speedX: BALL_BASE_SPEED * (Math.random() > 0.5 ? 1 : -1),
        speedY: BALL_BASE_SPEED * (Math.random() * 2 - 1),
        multiplier: 1.0
      };
      game.ballStateBuffer = [];
      game.lastUpdate = 0;
    }

    function drawGame() {
      // [Behalten Sie die vorhandene drawGame Funktion bei]
    }

    function updateGame(timestamp) {
      // [Behalten Sie die vorhandene updateGame Funktion bei]
    }

    function interpolateBall() {
      // [Behalten Sie die vorhandene interpolateBall Funktion bei]
    }

    // ============== SPIELSTEUERUNG ==============
    function startCountdown() {
      ui.readyScreen.style.display = "flex";
      let countdownTime = 3;
      const countdownElement = document.getElementById("countdown");
      const countdownInterval = setInterval(() => {
        countdownElement.textContent = countdownTime > 0 ? countdownTime : "GO!";
        countdownTime--;
        if (countdownTime < -1) {
          clearInterval(countdownInterval);
          ui.readyScreen.style.display = "none";
        }
      }, 1000);
    }

    function startGame(data) {
      console.log("Spielstart mit Daten:", data);
      
      if (!data || !data.playerNumber) {
        console.error("Ungültige Startdaten:", data);
        return;
      }

      game.playerNumber = data.playerNumber;
      game.isHost = (data.playerNumber === 1);
      
      if (data.canvasWidth && data.canvasHeight) {
        canvas.width = data.canvasWidth;
        canvas.height = data.canvasHeight;
      }
      game.canvasSize = { width: canvas.width, height: canvas.height };
      
      game.players[0].y = canvas.height / 2 - PADDLE_HEIGHT / 2;
      game.players[1].y = canvas.height / 2 - PADDLE_HEIGHT / 2;
      
      resetBall();
      game.players[0].score = 0;
      game.players[1].score = 0;
      ui.player1Score.textContent = "0";
      ui.player2Score.textContent = "0";
      
      game.running = true;
      ui.gameContainer.style.display = "block";
      ui.waitingScreen.style.display = "none";
      ui.scoreboard.style.display = "flex";
      ui.totalPlayers.style.display = "block";
      
      if (game.isHost) {
        startCountdown();
      } else {
        ui.readyScreen.style.display = "flex";
        document.getElementById("countdown").textContent = "GO!";
        setTimeout(() => {
          ui.readyScreen.style.display = "none";
        }, 1000);
      }
      
      game.lastFrameTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function resetGame() {
      console.log("Spiel wird zurückgesetzt");
      game.running = false;
      ui.gameContainer.style.display = "none";
      ui.scoreboard.style.display = "none";
      ui.waitingScreen.style.display = "flex";
      ui.totalPlayers.style.display = "none";
      game.players[0].score = 0;
      game.players[1].score = 0;
      ui.player1Score.textContent = "0";
      ui.player2Score.textContent = "0";
      game.ballStateBuffer = [];
      game.inQueue = false;
      ui.queueButton.textContent = "Warteschlange betreten";
      ui.queueStatus.textContent = "Nicht in Warteschlange";
    }

    function startTestMode() {
      console.log("Starte Testmodus");
      game.localMode = true;
      game.testMode = true;
      ui.testControls.style.display = "flex";
      game.playerNumber = 1;
      game.isHost = true;
      game.controlledPlayer = 1;
      startGame({
        playerNumber: 1,
        canvasWidth: window.innerWidth,
        canvasHeight: window.innerHeight
      });
    }

    // ============== NETZWERKFUNKTIONEN ==============
    function synchronizeClocks() {
      const start = Date.now();
      socket.send(JSON.stringify({
        type: "syncRequest",
        clientTime: start
      }));
      game.lastSyncTime = start;
    }

    function handleMessage(event) {
      if (game.localMode) return;

      try {
        const data = JSON.parse(event.data);
        console.log("Empfangene Nachricht:", data);

        switch (data.type) {
          case "syncResponse":
            game.clockOffset = Date.now() - ((data.clientTime + data.serverTime) / 2);
            break;
            
          case "playerCountUpdate":
            ui.playerCount.textContent = `${data.inQueue} Spieler in Warteschlange`;
            ui.totalPlayersCount.textContent = data.totalPlayers;
            break;
            
          case "joinedQueue":
            game.inQueue = true;
            ui.queueButton.textContent = "Verlasse Warteschlange";
            ui.queueStatus.textContent = `Position: ${data.position || 1}`;
            break;
            
          case "gameStart":
            console.log("Spielstart-Nachricht erhalten");
            startGame(data);
            break;
            
          case "gameState":
            if (data.isHost) {
              game.ballStateBuffer.push({
                ballX: data.ballX,
                ballY: data.ballY,
                ballSpeedX: data.ballSpeedX,
                ballSpeedY: data.ballSpeedY,
                timestamp: data.timestamp
              });
            }
            
            if (game.playerNumber === 1) {
              game.players[0].y = data.player1Y;
            } else if (game.playerNumber === 2) {
              game.players[1].y = data.player2Y;
            }
            break;
            
          case "scoreUpdate":
            if (data.player === 1) {
              game.players[0].score = data.score;
              ui.player1Score.textContent = data.score;
            } else {
              game.players[1].score = data.score;
              ui.player2Score.textContent = data.score;
            }
            break;
            
          default:
            console.log("Unbekannter Nachrichtentyp:", data.type);
        }
      } catch (error) {
        console.error('Nachrichtenverarbeitungsfehler:', error);
      }
    }

    function toggleQueue() {
      if (!game.inQueue) {
        console.log('Trete Warteschlange bei');
        game.inQueue = true;
        ui.queueButton.textContent = "Verlasse Warteschlange";
        ui.queueStatus.textContent = "Suche nach Gegner...";
        
        socket.send(JSON.stringify({ 
          type: 'joinQueue',
          canvasWidth: window.innerWidth,
          canvasHeight: window.innerHeight
        }));
      } else {
        console.log('Verlasse Warteschlange');
        game.inQueue = false;
        ui.queueButton.textContent = "Warteschlange betreten";
        ui.queueStatus.textContent = "Nicht in Warteschlange";
        
        socket.send(JSON.stringify({ type: 'leaveQueue' }));
      }
    }

    // ============== EVENT HANDLER ==============
    function handlePaddleMove(e) {
      if (!game.running) return;
      
      const rect = canvas.getBoundingClientRect();
      const mouseY = e.clientY - rect.top;
      
      if (game.testMode) {
        game.players[game.controlledPlayer-1].y = 
          Math.max(0, Math.min(mouseY - PADDLE_HEIGHT/2, canvas.height - PADDLE_HEIGHT));
      } else {
        const playerIndex = game.playerNumber - 1;
        const newY = Math.max(0, Math.min(mouseY - PADDLE_HEIGHT/2, canvas.height - PADDLE_HEIGHT));
        
        if (Math.abs(game.players[playerIndex].y - newY) > 1) {
          game.players[playerIndex].y = newY;

          if (!game.localMode) {
            socket.send(JSON.stringify({
              type: "paddleMove",
              player: game.playerNumber,
              y: newY,
              timestamp: Date.now()
            }));
          }
        }
      }
    }

    function handleTestKeys(e) {
      if (!game.testMode || !game.running) return;
      
      const moveAmount = 15;
      const player = game.controlledPlayer - 1;
      
      if (game.controlledPlayer === 1) {
        if (e.key === 'w') game.players[player].y = Math.max(0, game.players[player].y - moveAmount);
        if (e.key === 's') game.players[player].y = Math.min(canvas.height - PADDLE_HEIGHT, game.players[player].y + moveAmount);
      } 
      else if (game.controlledPlayer === 2) {
        if (e.key === 'ArrowUp') game.players[player].y = Math.max(0, game.players[player].y - moveAmount);
        if (e.key === 'ArrowDown') game.players[player].y = Math.min(canvas.height - PADDLE_HEIGHT, game.players[player].y + moveAmount);
      }
    }

    // ============== SPIELSCHLEIFE ==============
    function gameLoop(timestamp) {
      updateGame(timestamp);
      drawGame();
      if (game.running) {
        requestAnimationFrame(gameLoop);
      }
    }

    // ============== INITIALISIERUNG ==============
    window.addEventListener('resize', initCanvas);
    document.addEventListener('keydown', handleTestKeys);
    canvas.addEventListener('mousemove', handlePaddleMove);
    ui.controlPlayer1.addEventListener('click', () => {
      game.controlledPlayer = 1;
      console.log('Steuere nun Spieler 1');
    });
    ui.controlPlayer2.addEventListener('click', () => {
      game.controlledPlayer = 2;
      console.log('Steuere nun Spieler 2');
    });
    ui.localTestBtn.addEventListener('click', startTestMode);
    ui.queueButton.addEventListener('click', toggleQueue);

    // WebSocket Nachrichtenhandler
    socket.onmessage = handleMessage;

    // Initialisiere Canvas beim Laden
    window.addEventListener('load', initCanvas);
  </script>
</body>
</html>
